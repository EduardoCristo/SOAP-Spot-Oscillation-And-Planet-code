{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to SOAP's Documentation!","text":""},{"location":"#introduction","title":"Introduction","text":"<p>SOAPv4 (Spot Oscillation And Planet) is an open-source Python package that simulates the impact of stellar activity and planetary transits on spectroscopic, radial velocity, and photometric data. Accurate modeling of stellar features like spots and faculae is essential for robust exoplanet characterization, particularly with high-resolution spectroscopy.</p> <p>Initially built to reproduce the radial velocity effects of stellar spots, SOAP has broadened its scope across multiple versions. SOAPv4 now integrates a wide set of physical processes and observational configurations.</p>"},{"location":"#novelty-of-soapv4","title":"Novelty of SOAPv4","text":"<ul> <li>Extends beyond cross-correlation functions (CCFs) by providing time-resolved stellar spectra.</li> <li>Incorporates complex stellar activity effects: active regions, differential rotation, convective blueshift, and additonal sources of center-to-limb variations;</li> <li>Unifies past developments into a comprehensive modeling framework;</li> <li>Enables combined modeling of spectra, transit signals, photometry, and stellar variability for exoplanet studies;</li> <li>In particular, for exoplanet transit studies, it computes planet-occulted line distortions (POLDs) and the Doppler shadow, accounting for both center-to-limb variations (CLVs) and stellar activity.</li> </ul>"},{"location":"#some-of-the-use-cases-of-soap","title":"Some of the use cases of SOAP","text":"<p>SOAPv4 is especially suited for researchers who want to:</p> <ul> <li> <p>Compute time series of integrated stellar spectra</p> </li> <li> <p>Assess stellar contamination in exoplanet transit spectra</p> </li> <li> <p>Comput the photometric and radial velocity modulation of stellar activity</p> </li> <li> <p>Model the signal of transiting planets for a wide range of stellar/planetary system parameters  </p> </li> <li> <p>Model transmission spectra (POLDs) and Doppler shadow in a simple way</p> </li> <li> <p>...</p> </li> </ul>"},{"location":"#development-of-soap-through-time","title":"Development of SOAP through Time","text":"<p>The SOAP code (Boisse et al. 2012) was initially developed to model the influence of stellar activity, particularly starspots, on radial velocity (RV) time series. In its first implementation, SOAP represented the local stellar disk spectrum using cross-correlation functions (CCFs), approximated by Gaussian profiles with user-defined parameters. For each stellar surface element, the corresponding CCF was Doppler-shifted according to the local rotational velocity under the assumption of solid-body rotation and flux-weighted following a prescribed limb-darkening law.  </p> <p>Active regions (ARs) were introduced as circular features, mapped to their correct latitude and longitude through spherical coordinates transformation. The same Gaussian CCF profile was applied to ARs, with their contribution scaled by a contrast parameter: values between 0 and 1 denoting dark spots, and greater than 1 representing bright faculae. Although simplified, this framework provided a first-order tool for characterizing stellar activity-induced distortions in photometric and RV measurements.  </p> <p>Building on this foundation, subsequent developments progressively extended SOAP\u2019s functionality:  </p> <ul> <li> <p>SOAP-T (Oshagh et al. 2013) incorporated transiting exoplanets. The code simulated the occultation of quiet stellar surface regions during transits by subtracting their flux contribution. This approach enabled the simultaneous modeling of photometric light curves, Keplerian orbital motion, and the Rossiter\u2013McLaughlin effect, making SOAP-T a practical tool for studying the architecture of planetary systems. </p> </li> <li> <p>SOAP 2.0 (Dumusque et al. 2014) increased the physical realism of the code through the introduction of solar observed spectra. High-resolution Fourier Transform Spectrograph (FTS) data from Kitt Peak, including a quiet-sun spectrum (Wallace et al. 1998) and a sunspot umbral spectrum (Wallace et al. 2005), were used to construct the CCFs to be used in the simulations. This allowed more accurate modeling of stellar line-profile deformations, particularly the suppression of convective blueshift within ARs. SOAP 2.0  also incorporated facular limb brightening and spot/facula contrasts derived from the Planck function as a function of temperature differences.</p> </li> </ul> <p>Although not all intermediate versions were released publicly, key developments further expanded the framework:  </p> <ul> <li>Oshagh et al. (2016) combined SOAP-T and SOAP 2.0 elements to investigate how stellar activity biases measurements of planetary spin\u2013orbit misalignments and transmission spectra of exoplanets (using the chromatic Rossiter-McLaughlin technique).  </li> <li>Akinsanmi et al. (2018) added functionalities to simulate ringed planets and planetary rotational deformation, capturing their imprints on RVs and light curves during transits.  </li> <li>Serrano et al. (2020) and Cristo et al. (2024) incorporated stellar differential rotation (e.g., Balona &amp; Abedigamba 2016) and convective blueshift (Shporer &amp; Brown 2011) effect during planetary transits.</li> </ul> <p>In parallel, a dedicated branch emerged in the form of SOAP-GPU (Zhao &amp; Dumusque 2023). This version diverged from SOAP 2.0 by directly producing stellar spectra rather than synthetic CCFs. Features included explicit AR mapping, more detailed treatments of convective blueshift variations across the disk based on empirical solar measurements (L\u00f6hner-B\u00f6ttcher et al. 2019), and GPU-optimized performance.</p> <p></p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>SOAPv4 is publicly available on GitHub: https://github.com/EduardoCristo/SOAP-Spot-Oscillation-And-Planet-code</p> <p>For detailed installation and usage instructions, see the Install Guide.</p>"},{"location":"install/","title":"Install","text":"<p>SOAP is written Python. To install run the following commands:</p> <pre><code>git clone https://github.com/EduardoCristo/SOAP-Spot-Oscillation-And-Planet-code\n\ncd SOAP-Spot-Oscillation-And-Planet-code\n\npip install -e .\n</code></pre> <p>Then you can use SOAP from Python with:</p> <pre><code>import SOAP\n</code></pre>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#SOAP.Simulation","title":"<code>Simulation</code>","text":"<p>Simulation class for SOAP simulations. This class encapsulates the configuration and execution of SOAP simulations, which model the photometric and spectroscopic effects of stellar activity and planetary transits on observed signals.</p> <p>Attributes:</p> Name Type Description <code>star</code> <code>Star</code> <p>The star to be simulated. Defaults to the Sun if not provided.</p> <code>planet</code> <code>Planet</code> <p>The planet to be simulated. Defaults to a template planet if not provided.</p> <code>pixel</code> <code>CCF or Spectrum</code> <p>The CCF or spectrum for each pixel in the quiet star. Defaults to solar CCF.</p> <code>pixel_spot</code> <code>CCF or Spectrum</code> <p>The CCF or spectrum for the spot(s). Defaults to solar spot CCF.</p> <code>active_regions</code> <code>list of SOAP.ActiveRegion</code> <p>List of active regions to include in the simulation.</p> <code>ring</code> <code>Ring</code> <p>Optional ring system for the planet.</p> <code>nrho</code> <code>int</code> <p>Resolution for the active region's circumference.</p> <code>grid</code> <code>int</code> <p>Stellar grid resolution (grid x grid).</p> <code>inst_reso</code> <code>int</code> <p>Spectrograph resolution.</p> <code>wlll</code> <code>float</code> <p>Observation wavelength for temperature contrast by Planck's law, in Angstrom.</p> <code>resample_spectra</code> <code>int</code> <p>Resample the quiet star and spot spectra by this amount. No effect if using a CCF.</p> <code>interp_strategy</code> <code>str</code> <p>Strategy for interpolating pixel and pixel_spot to a common wavelength array.</p> <code>verbose</code> <code>bool</code> <p>If True, prints additional information during simulation.</p> <p>Methods:</p> Name Description <code>get_results</code> <p>Compute RV, FWHM, and BIS for a sequence of CCFs.</p> <code>set</code> <p>Set multiple attributes of the simulation at once.</p> <code>set_pixel</code> <p>Set the pixel, pixel_spot, and optionally pixel_plage for the simulation.</p> <code>plot</code> <p>Plot the simulation results.</p> <code>visualize</code> <p>Visualize the simulation output.</p> <code>visualize_animation</code> <p>Create an animated visualization of the simulation.</p> <code>plot_surface</code> <p>Plot the stellar surface.</p> <code>add_random_active_regions</code> <p>Add N random active regions (spots or plages) to the simulation.</p> <code>run_itot</code> <p>Calculate the CCF and total flux for the quiet star.</p> <code>calculate_signal</code> <p>Estimate photometric and spectroscopic effects for the simulation over a grid of stellar rotation phases.</p> <code>config_export</code> <p>Export the simulation configuration as a string for easy re-import.</p> Properties <p>_ccf_mode: Returns True if the simulation is in CCF mode. has_planet: Returns True if a planet is present in the simulation. has_active_regions: Returns True if active regions are present. has_ring: Returns True if the planet has a ring system.</p> Source code in <code>SOAP/SOAP.py</code> <pre><code>class Simulation:\n\n    \"\"\"\n    Simulation class for SOAP simulations.\n    This class encapsulates the configuration and execution of SOAP simulations, which model the photometric and spectroscopic effects of stellar activity and planetary transits on observed signals.\n\n    Attributes:\n        star (SOAP.Star): \n            The star to be simulated. Defaults to the Sun if not provided.\n        planet (SOAP.Planet): \n            The planet to be simulated. Defaults to a template planet if not provided.\n        pixel (SOAP.CCF or SOAP.Spectrum): \n            The CCF or spectrum for each pixel in the quiet star. Defaults to solar CCF.\n        pixel_spot (SOAP.CCF or SOAP.Spectrum): \n            The CCF or spectrum for the spot(s). Defaults to solar spot CCF.\n        active_regions (list of SOAP.ActiveRegion): \n            List of active regions to include in the simulation.\n        ring (SOAP.Ring): \n            Optional ring system for the planet.\n        nrho (int): \n            Resolution for the active region's circumference.\n        grid (int): \n            Stellar grid resolution (grid x grid).\n        inst_reso (int): \n            Spectrograph resolution.\n        wlll (float): \n            Observation wavelength for temperature contrast by Planck's law, in Angstrom.\n        resample_spectra (int): \n            Resample the quiet star and spot spectra by this amount. No effect if using a CCF.\n        interp_strategy (str): \n            Strategy for interpolating pixel and pixel_spot to a common wavelength array.\n        verbose (bool): \n            If True, prints additional information during simulation.\n\n    Methods:\n        get_results(rv, CCFs, skip_fwhm=False, skip_bis=False):\n            Compute RV, FWHM, and BIS for a sequence of CCFs.\n        set(**kwargs):\n            Set multiple attributes of the simulation at once.\n        set_pixel(pixel, pixel_spot=None, pixel_plage=None):\n            Set the pixel, pixel_spot, and optionally pixel_plage for the simulation.\n        plot(psi=None, **kwargs):\n            Plot the simulation results.\n        visualize(output, plot_type, lim=None, ref_wave=0, plot_lims=None, show_data=True):\n            Visualize the simulation output.\n        visualize_animation(output, plot_type, lim=None, ref_wave=0, plot_lims=None, interval=100, repeat=True):\n            Create an animated visualization of the simulation.\n        plot_surface(psi=None, fig=None, colors=(\"m\", \"b\"), plot_time=None):\n            Plot the stellar surface.\n        add_random_active_regions(N=2, plage=False):\n            Add N random active regions (spots or plages) to the simulation.\n        run_itot(skip_rv=False, cache=True):\n            Calculate the CCF and total flux for the quiet star.\n        calculate_signal(psi=None, skip_itot=True, skip_rv=False, skip_fwhm=False, skip_bis=False, renormalize_rv=True, save_ccf=False, template=None, itot=None, **kwargs):\n            Estimate photometric and spectroscopic effects for the simulation over a grid of stellar rotation phases.\n        config_export(simVar=\"sim\", show_all=False):\n            Export the simulation configuration as a string for easy re-import.\n\n    Properties:\n        _ccf_mode: Returns True if the simulation is in CCF mode.\n        has_planet: Returns True if a planet is present in the simulation.\n        has_active_regions: Returns True if active regions are present.\n        has_ring: Returns True if the planet has a ring system.\n    \"\"\"\n\n\n    def __init__(\n        self,\n        star=None,\n        planet=None,\n        pixel=\"CCF\",\n        pixel_spot=\"CCF\",\n        active_regions=None,\n        ring=None,\n        nrho=20,\n        grid=300,\n        inst_reso=115000,\n        wlll=5293.4115,\n        resample_spectra=1,\n        interp_strategy=\"spot2quiet\",\n        verbose=False\n    ):\n\n        self.star = star\n        self.planet = planet\n        self.verbose=verbose\n        # The default is the CCF, otherwhise there is a need to state the type explicitly\n        if pixel == \"CCF\":\n            self.pixel = deepcopy(_default_CCF)\n        else:\n            self.pixel = deepcopy(pixel)\n\n        if pixel_spot == \"CCF\":\n            self.pixel_spot = deepcopy(_default_CCF_active_region)\n        elif pixel_spot == None:\n            self.pixel_spot = None\n        else:\n            self.pixel_spot = deepcopy(pixel_spot)\n\n        _possible = (classes.CCF, classes.Spectrum)\n        if not issubclass(self.pixel.__class__, _possible):\n            raise ValueError(\"`pixel` can only be a CCF or a Spectrum\")\n        if pixel_spot:\n            if not issubclass(self.pixel_spot.__class__, _possible):\n                raise ValueError(\"`pixel_spot` can only be a CCF or a Spectrum\")\n\n            # Test if the spectrum size of the active region and spot are the same. If not it can follow two strategies:\n            # - spot2quiet: Interpolate the spot spectrum to match the quiet spectrum size\n            # - quet2spot : Interpolate the quiet spectrum to match the spot spectrum size\n            if not self._ccf_mode:\n                if self.pixel.n != self.pixel_spot.n:\n                    if interp_strategy == \"spot2quiet\":\n                        self.pixel_spot.interpolate_to(self.pixel.wave, inplace=True)\n                    elif interp_strategy == \"quiet2spot\":\n                        self.pixel.interpolate_to(self.pixel_spot.wave, inplace=True)\n                if verbose:\n                    print(f\"convolving spot spectra to R={inst_reso}\")\n                self.pixel_spot.convolve_to(inst_reso, inplace=True)\n                self.pixel_spot.resample(resample_spectra, inplace=True)\n\n                # convolve the quiet and spot spectra to the instrument resolution\n                if verbose:\n                    print(f\"convolving quiet star to R={inst_reso}\")\n                self.pixel.convolve_to(inst_reso, inplace=True)\n                # resample\n                self.pixel.resample(resample_spectra, inplace=True)\n        else:\n            # convolve the quiet and spot spectra to the instrument resolution\n            if verbose:\n                print(f\"convolving quiet star to R={inst_reso}\")\n            self.pixel.convolve_to(inst_reso, inplace=True)\n            # resample\n            self.pixel.resample(resample_spectra, inplace=True)\n        self.active_regions = active_regions\n        self.ring = ring\n\n        self.nrho = nrho\n        self.grid = grid\n        self.inst_reso = inst_reso\n        self.wlll = wlll\n\n        if self.star is None:\n            self.star = deepcopy(_default_STAR)  # Sun()\n\n        if self.planet is None:\n            self.planet = deepcopy(_default_PLANET)\n\n        elif self.planet is False:\n            self.planet = deepcopy(_default_PLANET)\n            self.planet.Rp = 0.0\n\n        self.planet.ring = self.ring\n        del self.ring\n\n        if self.active_regions is None:\n            self.active_regions = deepcopy(_default_ACTIVE_REGIONS)\n\n        self.itot_cached = False\n\n        # connect pixels with the star\n        self.star._pixel = self.pixel\n        self.star._pixel_spot = self.pixel_spot\n\n        # convert star's vrot to the same units as the pixel\n        self.star.set_vrot_units(self.pixel._rv_units)\n        if self._ccf_mode:\n            self.pixel.vrot = self.star.vrot\n            _precompile_gauss(self.pixel.rv)\n\n    # CCF mode or spectrum mode?\n    @property\n    def _ccf_mode(self):\n        return issubclass(self.pixel.__class__, classes.CCF)\n\n    def get_results(self, rv, CCFs, skip_fwhm=False, skip_bis=False):\n        # Initialize arrays to store the results\n        RVs = np.empty(CCFs.shape[0])\n        FWHMs = np.empty(CCFs.shape[0])\n        BISs = np.empty(CCFs.shape[0])\n\n        # Process each CCF sequentially\n        for i, ccf in enumerate(CCFs):\n            # Perform the computation for each CCF\n            if skip_bis and skip_fwhm:\n                RV = compute_rv(rv, ccf)\n                FW, BIS = 0.0, 0.0\n            elif skip_bis:\n                RV, FW = compute_rv_fwhm(rv, ccf)\n                BIS = 0.0\n            else:\n                RV, FW, BIS = compute_rv_fwhm_bis(rv, ccf)\n\n            # Store the results\n            RVs[i] = RV\n            FWHMs[i] = FW\n            BISs[i] = BIS\n\n        return RVs, FWHMs, BISs\n\n    @property\n    def has_planet(self):\n        if self.planet.Rp == 0:\n            self.planet.Mp = 0\n        return self.planet.Rp &gt; 0.0\n\n    @property\n    def has_active_regions(self):\n        counter = False\n        for ar in self.active_regions:\n            counter += bool(ar.size * ar.check)\n        return bool(counter)\n\n    @property\n    def has_ring(self):\n        return self.planet.has_ring\n\n    def __repr__(self):\n        if len(self.active_regions) == 0:\n            return (\n                f\"Simulation(\\n\\tR={self.inst_reso}, grid={self.grid}\\n\"\n                f\"\\t{self.star}\\n\"\n                f\"\\tno active regions\\n\"\n                f\"\\t{self.planet}\\n)\"\n            )\n        else:\n            return (\n                f\"Simulation(\\n\\tR={self.inst_reso}, grid={self.grid}\\n\"\n                f\"\\t{self.star}\\n\"\n                f\"\\t{self.active_regions}\\n\"\n                f\"\\t{self.planet}\\n)\"\n            )\n\n    def set(self, **kwargs):\n        \"\"\"Set (several) attributes of the simulation at once\"\"\"\n        for k, v in kwargs.items():\n            try:\n                getattr(self, k)\n                setattr(self, k, v)\n            except AttributeError:\n                print(f'attribute \"{k}\" does not exist')\n\n    def set_pixel(self, pixel, pixel_spot=None, pixel_plage=None):\n        \"\"\"Set this simulation's pixel\n\n        Args:\n            pixel (SOAP.CCF or SOAP.Spectrum):\n                The CCF or spectrum for each pixel in the quiet star\n            pixel_spot (SOAP.CCF or SOAP.Spectrum):\n                The CCF for the spots\n            pixel_plage (SOAP.CCF or SOAP.Spectrum):\n                The CCF for the plages\n        \"\"\"\n        pixel.vrot = self.star.vrot\n        self.pixel = pixel\n\n        if pixel_spot is not None:\n            self.pixel_spot = copy(pixel_spot)\n        if pixel_plage is not None:\n            raise NotImplementedError(\"spots and plages use the same pixel\")\n\n        # force recalculation of itot\n        self.itot_cached = False\n        # connect CCFs with the star\n        self.star._pixel = self.pixel\n        self.star._pixel_spot = self.pixel_spot\n\n    def plot(self, psi=None, **kwargs):\n        fig, axs, ani = plots.plot_simulation(self, psi=psi, **kwargs)\n        if ani is not None:\n            return ani\n\n    def visualize(\n        self, output, plot_type, lim=None, ref_wave=0, plot_lims=None, show_data=True\n    ):\n        return visualize(self, output, plot_type, lim, ref_wave, plot_lims, show_data)\n\n    def visualize_animation(\n        self,\n        output,\n        plot_type,\n        lim=None,\n        ref_wave=0,\n        plot_lims=None,\n        interval=100,\n        repeat=True,\n    ):\n        return animate_visualization(\n            self, output, plot_type, lim, ref_wave, plot_lims, interval, repeat\n        )\n\n    def plot_surface(self, psi=None, fig=None, colors=(\"m\", \"b\"), plot_time=None):\n        plots.plot_surface(self, psi, fig, colors, plot_time)\n\n    def add_random_active_regions(self, N=2, plage=False):\n        \"\"\"\n        Add a given number of active regions to the simulation, randomly\n        distributed in the stellar surface\n\n        Args:\n            N (int):\n                Number of active regions to add\n            plage (bool):\n                Whether to add plages or spots\n        \"\"\"\n        for _ in range(N):\n            AR = ActiveRegion.random()\n            if plage:\n                AR.type = \"plage\"\n            self.active_regions.append(AR)\n\n    def run_itot(self, skip_rv=False, cache=True):\n        \"\"\"Calculate the CCF and the total flux for the quiet star\"\"\"\n        if cache and self.itot_cached:\n            return self.pixel_quiet, self.flux_quiet\n\n        star = without_units(self.star)\n        if DEBUG:\n            t1 = time.time()\n        if self._ccf_mode:\n            pixel = without_units(self.pixel)\n            if skip_rv:\n                pixel_quiet = np.zeros(pixel.n_v)\n                flux_quiet = stspnumba.itot_flux(star.u1, star.u2, self.grid)\n            else:\n                pixel_quiet, flux_quiet = stspnumba.itot_rv(\n                    star.vrot,\n                    star.incl,\n                    star.u1,\n                    star.u2,\n                    self.star.diffrotB,\n                    self.star.diffrotC,\n                    self.star.cb1,\n                    self.grid,\n                    pixel.rv,\n                    pixel.intensity,\n                    pixel.v_interval,\n                    pixel.n_v,\n                )\n\n        else:\n            precompile_functions()\n            pixel = self.pixel.to_numba()\n            # pixel = without_units(self.pixel)\n            flux_quiet = stspnumba.itot_flux(star.u1, star.u2, self.grid)\n            pixel_quiet = stspnumba.itot_spectrum_par(\n                star.vrot,\n                star.incl,\n                star.u1,\n                star.u2,\n                self.star.diffrotB,\n                self.star.diffrotC,\n                self.star.cb1,\n                self.grid,\n                pixel,\n            )\n\n        if DEBUG:\n            print(\"finished itot, took %f sec\" % (time.time() - t1))\n            print(\"shape of pixel_quiet: %d\" % pixel_quiet.shape)\n            print(\"flux_quiet: %f\" % flux_quiet)\n\n        if cache:\n            self.itot_cached = True\n\n        self.pixel_quiet = pixel_quiet\n        self.flux_quiet = flux_quiet\n        return pixel_quiet, flux_quiet\n\n    def calculate_signal(\n        self,\n        psi=None,\n        skip_itot=True,\n        skip_rv=False,\n        skip_fwhm=False,\n        skip_bis=False,\n        renormalize_rv=True,\n        save_ccf=False,\n        template=None,\n        itot=None,\n        **kwargs,\n    ):\n        \"\"\"\n        Estimates the photometric and spectroscopic effects for a simulation over a grid of stellar rotation phases.\n\n        Attributes:\n            psi (array_like): Phases at which the signals will be calculated (in units of the stellar rotation period).\n            skip_itot (bool): If True, only calculate the quiet star once and cache it.\n            skip_rv (bool): If True, skip calculating the RV signal.\n            skip_fwhm (bool): If True, skip calculating the FWHM signal.\n            skip_bis (bool): If True, skip calculating the BIS signal.\n            renormalize_rv (bool): If True, set RV when the spot is not visible to 0.\n            save_ccf (bool): If True, save the output CCFs to a file.\n            template (dict): Input spectrum to construct the CCF. Must contain: \"wave\" (nm) and \"flux\" arrays.\n            itot (tuple): Precomputed quiet star pixel and flux to use instead of recalculating.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            output: Instance containing psi, flux, rv, rv_bconv, rv_flux, ccf_fwhm, ccf_bis, ccf_depth, itot_quiet, and itot_flux as attributes.\n\n        Raises:\n            ValueError: If input parameters are invalid.\n        \"\"\"\n        # deal with the phases array\n        if psi is None:\n            psi = _default_psi\n        psi = np.atleast_1d(psi)\n        if has_unit(psi):\n            psi = psi.value\n\n        star, planet = remove_units(self.star, self.planet)\n        active_regions = list(remove_units(*self.active_regions))\n\n        added_ring = False\n        if self.planet.ring is None:\n            # need a dummy ring which does nothing\n            self.planet.add_ring(fi=1.0, fe=1.0, ir=90, theta=0.0)\n            added_ring = True\n        ring = without_units(self.planet.ring)\n        date = (psi + 0.0) * star.prot\n\n        if itot:\n            pixel_quiet, flux_quiet = deepcopy(itot)\n            self.pixel_quiet, self.flux_quiet = pixel_quiet, flux_quiet\n            self.itot_pixel_quiet, self.itot_flux_quiet = deepcopy(\n                [pixel_quiet, flux_quiet]\n            )\n        else:\n            pixel_quiet, flux_quiet = self.run_itot(skip_rv, cache=skip_itot)\n            self.itot_pixel_quiet, self.itot_flux_quiet = deepcopy(\n                [pixel_quiet, flux_quiet]\n            )\n\n        FLUXstar = flux_quiet\n        pixel_flux = np.tile(pixel_quiet, (psi.size, 1))\n        pixel_bconv = np.tile(pixel_quiet, (psi.size, 1))\n        pixel_tot = np.tile(pixel_quiet, (psi.size, 1))\n\n        t1 = time.time()\n        if DEBUG:\n            None\n            # print(\"Active region pixel\")\n            # plt.plot(self.pixel_spot.wave, self.pixel_spot.flux )\n            # plt.xlabel(\"Wavelength\")\n            # plt.ylabel(\"Flux\")\n            # plt.show()\n        if self._ccf_mode:\n            pixel = without_units(self.pixel)\n            if self.pixel_spot:\n                pixel_spot = without_units(self.pixel_spot)\n        else:\n            pixel = self.pixel.to_numba()\n            if self.pixel_spot:\n                pixel_spot = self.pixel_spot.to_numba()\n        if DEBUG:\n            import matplotlib.pyplot as plt\n\n            plt.plot(pixel.rv, pixel.intensity)\n            plt.plot(pixel_spot.rv, pixel_spot.intensity)\n            plt.show()\n        if len(active_regions) != 0:\n            out = stspnumba.active_region_contributions(\n                psi,\n                star,\n                active_regions,\n                pixel,\n                pixel_spot,\n                self.grid,\n                self.nrho,\n                self.wlll,\n                planet,\n                ring,\n                self._ccf_mode,\n                skip_rv,\n            )\n            flux_spot = out[0]\n            if DEBUG:\n                try:\n                    plt.plot(flux_spot)\n                    plt.show()\n                    plt.plot(pixel_spot_flux.T)\n                    plt.show()\n                except:\n                    None\n\n            pixel_spot_bconv = out[1]\n            pixel_spot_flux = out[2]\n\n            pixel_spot_tot = out[3]\n            # total flux of the star affected by active regions\n            FLUXstar = FLUXstar - flux_spot\n            # plt.plot(FLUXstar)\n            # plt.show()\n            # CCF of the star affected by the flux effect of active regions\n            pixel_flux = pixel_flux - pixel_spot_flux\n            # CCF of the star affected by the convective blueshift effect of\n            # active regions\n            pixel_bconv = pixel_bconv - pixel_spot_bconv\n            # CCF of the star affected by the total effect of active regions\n            pixel_tot = pixel_tot - pixel_spot_tot\n            if DEBUG:\n                if skip_rv == False:\n                    plt.close()\n                    print(\"Effect of the spot in the spectra\")\n                    plt.plot(pixel_spot_tot.T / np.max(pixel_spot_tot, axis=1))\n                    plt.plot(pixel_tot.T / np.max(pixel_tot, axis=1), \"--\")\n                    plt.show()\n                else:\n                    None\n        if DEBUG:\n            t2 = time.time()\n            print(\"finished spot_scan_npsi, took %f sec\" % (t2 - t1))\n\n        if DEBUG:\n            print(self.has_planet)\n        if self.has_planet:\n            if not self._ccf_mode:\n\n                if DEBUG:\n                    import matplotlib.pyplot as plt\n\n                    plt.plot(pixel.wave, self.pixel.flux)\n                    plt.show()\n\n                out = stspnumba.planet_scan_ndate(\n                    star.vrot,\n                    star.incl,\n                    date,\n                    date.size,\n                    star.u1,\n                    star.u2,\n                    self.grid,\n                    pixel.wave,\n                    self.pixel.to_numba(),\n                    self.pixel.v_interval,\n                    self.pixel.n_v,\n                    pixel.n,\n                    planet.P,\n                    planet.t0,\n                    planet.e,\n                    planet.w,\n                    planet.ip,\n                    planet.a,\n                    planet.lbda,\n                    planet.Rp,\n                    ring.fe,\n                    ring.fi,\n                    ring.theta + planet.lbda,\n                    ring.ir,\n                    not skip_rv,\n                    \"spectrum\",\n                    self.star.diffrotB,\n                    self.star.diffrotC,\n                    self.star.cb1,\n                )\n\n                if DEBUG:\n                    print(\"I have a planet!\")\n                    plt.plot(pixel.wave, out[0].T)\n                    plt.show()\n\n            else:\n                t1 = time.time()\n\n                # calculate the flux and CCF contribution from the planet\n                out = stspnumba.planet_scan_ndate(\n                    star.vrot,\n                    star.incl,\n                    date,\n                    date.size,\n                    star.u1,\n                    star.u2,\n                    self.grid,\n                    pixel.rv,\n                    pixel.intensity,\n                    pixel.v_interval,\n                    pixel.n_v,\n                    pixel.n,\n                    planet.P,\n                    planet.t0,\n                    planet.e,\n                    planet.w,\n                    planet.ip,\n                    planet.a,\n                    planet.lbda,\n                    planet.Rp,\n                    ring.fe,\n                    ring.fi,\n                    ring.theta + planet.lbda,\n                    ring.ir,\n                    not skip_rv,\n                    \"ccf\",\n                    self.star.diffrotB,\n                    self.star.diffrotC,\n                    self.star.cb1,\n                )\n                if DEBUG:\n                    import matplotlib.pyplot as plt\n\n                    plt.plot(out[0].T)\n                    plt.show()\n\n            # not skip_rv\n            # theta is modified to follow ldba (i.e measured from transit chord)\n\n            pixel_planet, FLUX_planet, self.xyzplanet = out\n\n            t2 = time.time()\n            # remove the contribution from the planet\n            FLUXstar = FLUXstar - FLUX_planet\n            pixel_flux = pixel_flux - pixel_planet\n            pixel_bconv = pixel_bconv\n            old_pixel_tot = deepcopy(pixel_tot)\n            pixel_tot = pixel_tot - pixel_planet\n        # normalize the flux of the star\n        FLUXstar = FLUXstar / flux_quiet\n\n        if added_ring:\n            self.planet.remove_ring()\n        # put units on the flux (with in-place conversion, avoiding copies)\n        FLUXstar &lt;&lt;= pp1\n\n        if skip_rv:\n            # out.rv=None by defaults\n            out = output(psi=psi, flux=FLUXstar)\n            return out\n        n1 = np.max(pixel_flux, axis=1)\n\n        # normalization\n        self.pixel_flux = pixel_flux = (pixel_flux.T / np.max(pixel_flux, axis=1)).T\n        self.pixel_bconv = pixel_bconv = (pixel_bconv.T / np.max(pixel_bconv, axis=1)).T\n        self.pixel_tot = pixel_tot = (pixel_tot.T / np.max(pixel_tot, axis=1)).T\n\n        # self.pixel_quiet = pixel_quiet = pixel_quiet / max(pixel_quiet)\n\n        # return pixel_flux, pixel_bconv\n\n        if self._ccf_mode:\n            out = stspnumba.clip_ccfs(\n                pixel, pixel_flux, pixel_bconv, pixel_tot, pixel_quiet\n            )\n            pixel_flux, pixel_bconv, pixel_tot, pixel_quiet = out\n\n            out = stspnumba.convolve_ccfs(\n                pixel, self.inst_reso, pixel_quiet, pixel_flux, pixel_bconv, pixel_tot\n            )\n            pixel_quiet, pixel_flux, pixel_bconv, pixel_tot = out\n            if DEBUG:\n                import matplotlib.pyplot as plt\n\n                print(\"I have a planet!\")\n                plt.plot(pixel.rv, pixel_flux.T)\n                plt.show()\n\n            # calculate the CCF parameters RV, depth, BIS SPAN, and FWHM, for each\n            # of the contributions flux, bconv and total\n            _rv = pixel.rv\n\n            t1 = time.time()\n            if DEBUG:\n                import matplotlib.pyplot as plt\n\n                plt.close()\n                for k in pixel_flux:\n                    plt.plot(_rv, k)\n                plt.show()\n            # Check this\n            if skip_bis and skip_fwhm:\n                rv_flux = compute_rv_2d(_rv, pixel_flux)\n                fwhm_flux, span_flux = 0.0, 0.0\n                rv_bconv = compute_rv_2d(_rv, pixel_bconv)\n                fwhm_bconv, span_bconv = 0.0, 0.0\n                rv_tot = compute_rv_2d(_rv, pixel_bconv)\n                fwhm_tot, span_tot = 0.0, 0.0\n            elif skip_bis:\n                rv_flux, fwhm_flux = compute_rv_fwhm_2d(_rv, pixel_flux).T\n                span_flux = 0.0\n                rv_bconv, fwhm_bconv = compute_rv_fwhm_2d(_rv, pixel_bconv).T\n                span_bconv = 0.0\n                rv_tot, fwhm_tot = compute_rv_fwhm_2d(_rv, pixel_tot).T\n                span_tot = 0.0\n            else:\n                _ = compute_rv_fwhm_bis_2d(_rv, pixel_flux).T\n                rv_flux, fwhm_flux, span_flux = _\n                _ = compute_rv_fwhm_bis_2d(_rv, pixel_bconv).T\n                rv_bconv, fwhm_bconv, span_bconv = _\n                _ = compute_rv_fwhm_bis_2d(_rv, pixel_tot).T\n                rv_tot, fwhm_tot, span_tot = _\n\n            depth_tot = None\n\n            if DEBUG:\n                print(\"finished map(bis), took %f sec\" % (time.time() - t1))\n\n        else:\n            if self.verbose:\n                print(\"Computing CCFs for each spectra\")\n            _rv= np.arange(-20, 20 + 0.5, 0.5)\n            _precompile_gauss(_rv)\n\n            t1 = time.time()\n            if template:\n                ccf_pixel_flux = np.array(\n                    [\n                        stspnumba.calculate_ccf(\n                            template[\"wave\"], template[\"flux\"], self.pixel.wave, i\n                        )[1]\n                        for i in pixel_flux\n                    ]\n                )\n            else:\n                ccf_pixel_flux = np.array(\n                    [\n                        stspnumba.calculate_ccf(\n                            self.pixel.wave, self.pixel.flux, self.pixel.wave, i\n                        )[1]\n                        for i in pixel_flux\n                    ]\n                )\n\n            if DEBUG:\n                print(\"I am in line 965\")\n                plt.plot(_rv, ccf_pixel_flux.T)\n                plt.show()\n\n            _ = self.get_results(_rv, ccf_pixel_flux, skip_fwhm, skip_bis)\n            rv_flux, fwhm_flux, span_flux = _\n            if template:\n                ccf_pixel_bconv = np.array(\n                    [\n                        stspnumba.calculate_ccf(\n                            template[\"wave\"], template[\"flux\"], self.pixel.wave, i\n                        )[1]\n                        for i in pixel_bconv\n                    ]\n                )\n            else:\n                ccf_pixel_bconv = np.array(\n                    [\n                        stspnumba.calculate_ccf(\n                            self.pixel.wave, self.pixel.flux, self.pixel.wave, i\n                        )[1]\n                        for i in pixel_bconv\n                    ]\n                )\n\n            _ = self.get_results(_rv, ccf_pixel_bconv, skip_fwhm, skip_bis)\n            rv_bconv, fwhm_bconv, span_bconv = _\n            if template:\n                ccf_pixel_tot = np.array(\n                    [\n                        stspnumba.calculate_ccf(\n                            template[\"wave\"], template[\"flux\"], self.pixel.wave, i\n                        )[1]\n                        for i in pixel_tot\n                    ]\n                )\n            else:\n                ccf_pixel_tot = np.array(\n                    [\n                        stspnumba.calculate_ccf(\n                            self.pixel.wave, self.pixel.flux, self.pixel.wave, i\n                        )[1]\n                        for i in pixel_tot\n                    ]\n                )\n            self.ccf=ccf_pixel_tot\n            self.rv=_rv\n            _ = self.get_results(_rv, ccf_pixel_tot, skip_fwhm, skip_bis)\n            rv_tot, fwhm_tot, span_tot = _\n            if DEBUG:\n                plt.plot(rv_tot)\n                plt.show()\n            depth_tot = None\n\n            if DEBUG:\n                print(\"finished map(bis), took %f sec\" % (time.time() - t1))\n\n        if renormalize_rv:\n            # find where rv_flux = rv_bconv, which corresponds to the phases\n            # where the active regions are not visible\n            index_equal_rv = np.where((rv_flux - rv_bconv) == 0)[0]\n            if len(index_equal_rv) != 0:\n                # velocity when the spot is not visible\n                zero_velocity = rv_flux[index_equal_rv][0]\n                # set velocity when the active region is not visible to 0\n                rv_flux -= zero_velocity\n                rv_bconv -= zero_velocity\n                rv_tot -= zero_velocity\n                if not skip_fwhm:\n                    # FWHM when the spot is not visible\n                    zero_fw = fwhm_flux[index_equal_rv][0]\n                    # set FWHM when the active region is not visible to 0\n                    fwhm_flux -= zero_fw\n                    fwhm_bconv -= zero_fw\n                    fwhm_tot -= zero_fw\n                if not skip_bis:\n                    # BIS when the spot is not visible\n                    zero_bis = span_flux[index_equal_rv][0]\n                    # set FWHM when the active region is not visible to 0\n                    span_flux -= zero_bis\n                    span_bconv -= zero_bis\n                    span_tot -= zero_bis\n        self.integrated_spectra = self.pixel_tot\n        ###################\n        if self.has_planet:\n\n            tr_dur = (\n                1.0\n                / np.pi\n                * np.arcsin(\n                    1.0\n                    / (self.planet.a).value\n                    * np.sqrt(\n                        (1 + (self.planet.Rp).value) ** 2.0\n                        - (self.planet.a).value ** 2.0\n                        * np.cos(np.radians((self.planet.ip).value)) ** 2.0\n                    )\n                )\n            )\n            try:\n                planet_phases = psi * self.star.prot / self.planet.P\n                phase_mask = np.logical_or(\n                    planet_phases &lt; -tr_dur / 2, planet_phases &gt; tr_dur / 2\n                )\n                # Note: There is not effect of the keplerian here, so everything is in the stellar rest-frame unless we have \n                # a AR\n                rv_tot_out = rv_tot[phase_mask]\n                psi_out = planet_phases[phase_mask]\n\n                slope_coefs = np.polyfit(psi_out, rv_tot_out, deg=1)\n\n                slope_rvs = slope_coefs[0] * planet_phases + slope_coefs[1]\n\n                if DEBUG == True:\n                    print(\"Slopes coefficients out-of-transit\")\n                    print(slope_coefs)\n                    print(\"RVs out-of-transit\")\n                    print(rv_tot_out)\n                    print(\"RVs obtained from a linear fit from the out-of-transit\")\n                    print(slope_rvs)\n\n                corr_pixel_flux = np.array(\n                    [\n                        stspnumba.doppler_shift(pixel.wave, pixel_tot[i], -slope_rvs[i])\n                        for i in range(len(pixel_tot))\n                    ]\n                )\n\n                # Carefull! When we have an active region, the master out does not correspond to pflux, the user must make it manually!\n                flux_weighted_spectra = np.array(\n                    [\n                        corr_pixel_flux[j] * FLUXstar[j]\n                        for j in range(len(corr_pixel_flux))\n                    ]\n                )\n                self.master_out_fw = np.mean(flux_weighted_spectra[phase_mask], axis=0)\n                self.integrated_spectra_fw = flux_weighted_spectra\n\n                master_out = np.mean(corr_pixel_flux[phase_mask], axis=0)\n                self.pixel_trans = corr_pixel_flux / master_out\n                self.integrated_spectra = corr_pixel_flux\n            except:\n                None\n\n        ###################\n        # put back the units (with in-place conversion, avoiding copies)\n        rv_flux &lt;&lt;= self.pixel._rv_units\n        rv_bconv &lt;&lt;= self.pixel._rv_units\n        rv_tot &lt;&lt;= self.pixel._rv_units\n        if not skip_fwhm:\n            fwhm_flux &lt;&lt;= self.pixel._rv_units\n            fwhm_bconv &lt;&lt;= self.pixel._rv_units\n            fwhm_tot &lt;&lt;= self.pixel._rv_units\n        if not skip_bis:\n            span_flux &lt;&lt;= self.pixel._rv_units\n            span_bconv &lt;&lt;= self.pixel._rv_units\n            span_tot &lt;&lt;= self.pixel._rv_units\n\n        if self.has_planet:\n            rv_kep = self.planet.rv_curve(psi * star.prot, stellar_mass=star.mass)\n\n            if not self._ccf_mode:\n                # shift by the Keplerian RV\n                for i in range(pixel_tot.shape[0]):\n                    pixel_tot[i] = stspnumba.doppler_shift(\n                        pixel.wave, pixel_tot[i], rv_kep[i].value\n                    )\n            else:\n                # shift by the Keplerian RV\n                for i in range(pixel_tot.shape[0]):\n                    pixel_tot[i] = stspnumba.linear_interpolator(\n                        pixel.rv, pixel_tot[i], pixel.rv-rv_kep[i].value\n                    )\n\n            # add Keplerian signal to final RVs\n            rv_tot += rv_kep\n\n        self.pixel_tot = pixel_tot\n\n        out = output(\n            psi=psi,\n            flux=FLUXstar,\n            rv=rv_tot,\n            rv_bconv=rv_bconv,\n            rv_flux=rv_flux,\n            ccf_fwhm=fwhm_tot,\n            ccf_bis=span_tot,\n            ccf_depth=depth_tot,\n            itot_quiet=self.itot_pixel_quiet,\n            itot_flux=self.itot_flux_quiet,\n        )\n        return out\n\n    def config_export(self, simVar=\"sim\", show_all=False):\n        \"\"\"\n        Return list (as string) of all variables that can easily be re-imported.\n        \"\"\"\n\n        if type(simVar) is not str:\n            raise TypeError(\"simVar must be type 'str' not {}.\".format(type(simVar)))\n\n        outputstring = \"\"\n\n        # run over all of simulation's attributes\n        for key1 in self.__dict__.keys():\n\n            # skip some values\n            if not show_all:\n                if key1 in [\"ccf\", \"ccf_active_region\", \"itot_cached\", \"xyzplanet\"]:\n                    continue\n\n            a1 = self.__getattribute__(key1)\n\n            # Object planet and star have second layer\n            if key1 in [\"planet\", \"star\"]:\n\n                if key1 == \"planet\":\n                    outputstring += \"\\n# %s.has_planet = {}\".format(self.has_planet) % (\n                        simVar\n                    )\n\n                for key2 in a1.__dict__.keys():\n\n                    # skip some values\n                    if not show_all:\n                        if key2 in [\"diffrotB\", \"diffrotC\", \"start_psi\", \"rad_sun\"]:\n                            continue\n\n                    a2 = a1.__getattribute__(key2)\n\n                    # ring has third layer\n                    if key2 == \"ring\" and a2 is not None:\n                        outputstring += \"\\n\"\n                        outputstring += \"\\n# %s.planet.has_ring = {}\".format(\n                            self.planet.has_ring\n                        ) % (simVar)\n                        for key3 in a2.__dict__.keys():\n                            a3 = a2.__getattribute__(key3)\n                            outputstring += \"\\n%s.%s.%s.%s = {}\".format(a3) % (\n                                simVar,\n                                key1,\n                                key2,\n                                key3,\n                            )\n                    else:\n                        outputstring += \"\\n%s.%s.%s = {}\".format(a2) % (\n                            simVar,\n                            key1,\n                            key2,\n                        )\n                outputstring += \"\\n\"\n\n            # active regions are list\n            elif key1 == \"active_regions\":\n                outputstring += \"\\n# %s.has_active_regions = {}\".format(\n                    self.has_active_regions\n                ) % (simVar)\n                outputstring += \"\\n%s.active_regions = [\" % (simVar)\n                for ar in a1:\n                    outputstring += (\n                        'SOAP.ActiveRegion(lon=%.9g,lat=%.9g,size=%.9g,active_region_type=\"%s\",check=%i),'\n                        % (ar.lon, ar.lat, ar.size, ar.type, ar.check)\n                    )\n                outputstring += \"]\"\n                outputstring += \"\\n\"\n\n            # all other paramters (first layer)\n            else:\n                outputstring += \"\\n%s.%s = {}\".format(a1) % (simVar, key1)\n\n        # remove first linebreaks and add linebreak at end\n        while outputstring[0] == \"\\n\":\n            outputstring = outputstring[1:]\n        outputstring += \"\\n\"\n\n        return outputstring\n</code></pre>"},{"location":"reference/#SOAP.Simulation.add_random_active_regions","title":"<code>add_random_active_regions(N=2, plage=False)</code>","text":"<p>Add a given number of active regions to the simulation, randomly distributed in the stellar surface</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of active regions to add</p> <code>2</code> <code>plage</code> <code>bool</code> <p>Whether to add plages or spots</p> <code>False</code> Source code in <code>SOAP/SOAP.py</code> <pre><code>def add_random_active_regions(self, N=2, plage=False):\n    \"\"\"\n    Add a given number of active regions to the simulation, randomly\n    distributed in the stellar surface\n\n    Args:\n        N (int):\n            Number of active regions to add\n        plage (bool):\n            Whether to add plages or spots\n    \"\"\"\n    for _ in range(N):\n        AR = ActiveRegion.random()\n        if plage:\n            AR.type = \"plage\"\n        self.active_regions.append(AR)\n</code></pre>"},{"location":"reference/#SOAP.Simulation.calculate_signal","title":"<code>calculate_signal(psi=None, skip_itot=True, skip_rv=False, skip_fwhm=False, skip_bis=False, renormalize_rv=True, save_ccf=False, template=None, itot=None, **kwargs)</code>","text":"<p>Estimates the photometric and spectroscopic effects for a simulation over a grid of stellar rotation phases.</p> <p>Attributes:</p> Name Type Description <code>psi</code> <code>array_like</code> <p>Phases at which the signals will be calculated (in units of the stellar rotation period).</p> <code>skip_itot</code> <code>bool</code> <p>If True, only calculate the quiet star once and cache it.</p> <code>skip_rv</code> <code>bool</code> <p>If True, skip calculating the RV signal.</p> <code>skip_fwhm</code> <code>bool</code> <p>If True, skip calculating the FWHM signal.</p> <code>skip_bis</code> <code>bool</code> <p>If True, skip calculating the BIS signal.</p> <code>renormalize_rv</code> <code>bool</code> <p>If True, set RV when the spot is not visible to 0.</p> <code>save_ccf</code> <code>bool</code> <p>If True, save the output CCFs to a file.</p> <code>template</code> <code>dict</code> <p>Input spectrum to construct the CCF. Must contain: \"wave\" (nm) and \"flux\" arrays.</p> <code>itot</code> <code>tuple</code> <p>Precomputed quiet star pixel and flux to use instead of recalculating.</p> <code>**kwargs</code> <code>tuple</code> <p>Additional keyword arguments.</p> <p>Returns:</p> Name Type Description <code>output</code> <p>Instance containing psi, flux, rv, rv_bconv, rv_flux, ccf_fwhm, ccf_bis, ccf_depth, itot_quiet, and itot_flux as attributes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are invalid.</p> Source code in <code>SOAP/SOAP.py</code> <pre><code>def calculate_signal(\n    self,\n    psi=None,\n    skip_itot=True,\n    skip_rv=False,\n    skip_fwhm=False,\n    skip_bis=False,\n    renormalize_rv=True,\n    save_ccf=False,\n    template=None,\n    itot=None,\n    **kwargs,\n):\n    \"\"\"\n    Estimates the photometric and spectroscopic effects for a simulation over a grid of stellar rotation phases.\n\n    Attributes:\n        psi (array_like): Phases at which the signals will be calculated (in units of the stellar rotation period).\n        skip_itot (bool): If True, only calculate the quiet star once and cache it.\n        skip_rv (bool): If True, skip calculating the RV signal.\n        skip_fwhm (bool): If True, skip calculating the FWHM signal.\n        skip_bis (bool): If True, skip calculating the BIS signal.\n        renormalize_rv (bool): If True, set RV when the spot is not visible to 0.\n        save_ccf (bool): If True, save the output CCFs to a file.\n        template (dict): Input spectrum to construct the CCF. Must contain: \"wave\" (nm) and \"flux\" arrays.\n        itot (tuple): Precomputed quiet star pixel and flux to use instead of recalculating.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        output: Instance containing psi, flux, rv, rv_bconv, rv_flux, ccf_fwhm, ccf_bis, ccf_depth, itot_quiet, and itot_flux as attributes.\n\n    Raises:\n        ValueError: If input parameters are invalid.\n    \"\"\"\n    # deal with the phases array\n    if psi is None:\n        psi = _default_psi\n    psi = np.atleast_1d(psi)\n    if has_unit(psi):\n        psi = psi.value\n\n    star, planet = remove_units(self.star, self.planet)\n    active_regions = list(remove_units(*self.active_regions))\n\n    added_ring = False\n    if self.planet.ring is None:\n        # need a dummy ring which does nothing\n        self.planet.add_ring(fi=1.0, fe=1.0, ir=90, theta=0.0)\n        added_ring = True\n    ring = without_units(self.planet.ring)\n    date = (psi + 0.0) * star.prot\n\n    if itot:\n        pixel_quiet, flux_quiet = deepcopy(itot)\n        self.pixel_quiet, self.flux_quiet = pixel_quiet, flux_quiet\n        self.itot_pixel_quiet, self.itot_flux_quiet = deepcopy(\n            [pixel_quiet, flux_quiet]\n        )\n    else:\n        pixel_quiet, flux_quiet = self.run_itot(skip_rv, cache=skip_itot)\n        self.itot_pixel_quiet, self.itot_flux_quiet = deepcopy(\n            [pixel_quiet, flux_quiet]\n        )\n\n    FLUXstar = flux_quiet\n    pixel_flux = np.tile(pixel_quiet, (psi.size, 1))\n    pixel_bconv = np.tile(pixel_quiet, (psi.size, 1))\n    pixel_tot = np.tile(pixel_quiet, (psi.size, 1))\n\n    t1 = time.time()\n    if DEBUG:\n        None\n        # print(\"Active region pixel\")\n        # plt.plot(self.pixel_spot.wave, self.pixel_spot.flux )\n        # plt.xlabel(\"Wavelength\")\n        # plt.ylabel(\"Flux\")\n        # plt.show()\n    if self._ccf_mode:\n        pixel = without_units(self.pixel)\n        if self.pixel_spot:\n            pixel_spot = without_units(self.pixel_spot)\n    else:\n        pixel = self.pixel.to_numba()\n        if self.pixel_spot:\n            pixel_spot = self.pixel_spot.to_numba()\n    if DEBUG:\n        import matplotlib.pyplot as plt\n\n        plt.plot(pixel.rv, pixel.intensity)\n        plt.plot(pixel_spot.rv, pixel_spot.intensity)\n        plt.show()\n    if len(active_regions) != 0:\n        out = stspnumba.active_region_contributions(\n            psi,\n            star,\n            active_regions,\n            pixel,\n            pixel_spot,\n            self.grid,\n            self.nrho,\n            self.wlll,\n            planet,\n            ring,\n            self._ccf_mode,\n            skip_rv,\n        )\n        flux_spot = out[0]\n        if DEBUG:\n            try:\n                plt.plot(flux_spot)\n                plt.show()\n                plt.plot(pixel_spot_flux.T)\n                plt.show()\n            except:\n                None\n\n        pixel_spot_bconv = out[1]\n        pixel_spot_flux = out[2]\n\n        pixel_spot_tot = out[3]\n        # total flux of the star affected by active regions\n        FLUXstar = FLUXstar - flux_spot\n        # plt.plot(FLUXstar)\n        # plt.show()\n        # CCF of the star affected by the flux effect of active regions\n        pixel_flux = pixel_flux - pixel_spot_flux\n        # CCF of the star affected by the convective blueshift effect of\n        # active regions\n        pixel_bconv = pixel_bconv - pixel_spot_bconv\n        # CCF of the star affected by the total effect of active regions\n        pixel_tot = pixel_tot - pixel_spot_tot\n        if DEBUG:\n            if skip_rv == False:\n                plt.close()\n                print(\"Effect of the spot in the spectra\")\n                plt.plot(pixel_spot_tot.T / np.max(pixel_spot_tot, axis=1))\n                plt.plot(pixel_tot.T / np.max(pixel_tot, axis=1), \"--\")\n                plt.show()\n            else:\n                None\n    if DEBUG:\n        t2 = time.time()\n        print(\"finished spot_scan_npsi, took %f sec\" % (t2 - t1))\n\n    if DEBUG:\n        print(self.has_planet)\n    if self.has_planet:\n        if not self._ccf_mode:\n\n            if DEBUG:\n                import matplotlib.pyplot as plt\n\n                plt.plot(pixel.wave, self.pixel.flux)\n                plt.show()\n\n            out = stspnumba.planet_scan_ndate(\n                star.vrot,\n                star.incl,\n                date,\n                date.size,\n                star.u1,\n                star.u2,\n                self.grid,\n                pixel.wave,\n                self.pixel.to_numba(),\n                self.pixel.v_interval,\n                self.pixel.n_v,\n                pixel.n,\n                planet.P,\n                planet.t0,\n                planet.e,\n                planet.w,\n                planet.ip,\n                planet.a,\n                planet.lbda,\n                planet.Rp,\n                ring.fe,\n                ring.fi,\n                ring.theta + planet.lbda,\n                ring.ir,\n                not skip_rv,\n                \"spectrum\",\n                self.star.diffrotB,\n                self.star.diffrotC,\n                self.star.cb1,\n            )\n\n            if DEBUG:\n                print(\"I have a planet!\")\n                plt.plot(pixel.wave, out[0].T)\n                plt.show()\n\n        else:\n            t1 = time.time()\n\n            # calculate the flux and CCF contribution from the planet\n            out = stspnumba.planet_scan_ndate(\n                star.vrot,\n                star.incl,\n                date,\n                date.size,\n                star.u1,\n                star.u2,\n                self.grid,\n                pixel.rv,\n                pixel.intensity,\n                pixel.v_interval,\n                pixel.n_v,\n                pixel.n,\n                planet.P,\n                planet.t0,\n                planet.e,\n                planet.w,\n                planet.ip,\n                planet.a,\n                planet.lbda,\n                planet.Rp,\n                ring.fe,\n                ring.fi,\n                ring.theta + planet.lbda,\n                ring.ir,\n                not skip_rv,\n                \"ccf\",\n                self.star.diffrotB,\n                self.star.diffrotC,\n                self.star.cb1,\n            )\n            if DEBUG:\n                import matplotlib.pyplot as plt\n\n                plt.plot(out[0].T)\n                plt.show()\n\n        # not skip_rv\n        # theta is modified to follow ldba (i.e measured from transit chord)\n\n        pixel_planet, FLUX_planet, self.xyzplanet = out\n\n        t2 = time.time()\n        # remove the contribution from the planet\n        FLUXstar = FLUXstar - FLUX_planet\n        pixel_flux = pixel_flux - pixel_planet\n        pixel_bconv = pixel_bconv\n        old_pixel_tot = deepcopy(pixel_tot)\n        pixel_tot = pixel_tot - pixel_planet\n    # normalize the flux of the star\n    FLUXstar = FLUXstar / flux_quiet\n\n    if added_ring:\n        self.planet.remove_ring()\n    # put units on the flux (with in-place conversion, avoiding copies)\n    FLUXstar &lt;&lt;= pp1\n\n    if skip_rv:\n        # out.rv=None by defaults\n        out = output(psi=psi, flux=FLUXstar)\n        return out\n    n1 = np.max(pixel_flux, axis=1)\n\n    # normalization\n    self.pixel_flux = pixel_flux = (pixel_flux.T / np.max(pixel_flux, axis=1)).T\n    self.pixel_bconv = pixel_bconv = (pixel_bconv.T / np.max(pixel_bconv, axis=1)).T\n    self.pixel_tot = pixel_tot = (pixel_tot.T / np.max(pixel_tot, axis=1)).T\n\n    # self.pixel_quiet = pixel_quiet = pixel_quiet / max(pixel_quiet)\n\n    # return pixel_flux, pixel_bconv\n\n    if self._ccf_mode:\n        out = stspnumba.clip_ccfs(\n            pixel, pixel_flux, pixel_bconv, pixel_tot, pixel_quiet\n        )\n        pixel_flux, pixel_bconv, pixel_tot, pixel_quiet = out\n\n        out = stspnumba.convolve_ccfs(\n            pixel, self.inst_reso, pixel_quiet, pixel_flux, pixel_bconv, pixel_tot\n        )\n        pixel_quiet, pixel_flux, pixel_bconv, pixel_tot = out\n        if DEBUG:\n            import matplotlib.pyplot as plt\n\n            print(\"I have a planet!\")\n            plt.plot(pixel.rv, pixel_flux.T)\n            plt.show()\n\n        # calculate the CCF parameters RV, depth, BIS SPAN, and FWHM, for each\n        # of the contributions flux, bconv and total\n        _rv = pixel.rv\n\n        t1 = time.time()\n        if DEBUG:\n            import matplotlib.pyplot as plt\n\n            plt.close()\n            for k in pixel_flux:\n                plt.plot(_rv, k)\n            plt.show()\n        # Check this\n        if skip_bis and skip_fwhm:\n            rv_flux = compute_rv_2d(_rv, pixel_flux)\n            fwhm_flux, span_flux = 0.0, 0.0\n            rv_bconv = compute_rv_2d(_rv, pixel_bconv)\n            fwhm_bconv, span_bconv = 0.0, 0.0\n            rv_tot = compute_rv_2d(_rv, pixel_bconv)\n            fwhm_tot, span_tot = 0.0, 0.0\n        elif skip_bis:\n            rv_flux, fwhm_flux = compute_rv_fwhm_2d(_rv, pixel_flux).T\n            span_flux = 0.0\n            rv_bconv, fwhm_bconv = compute_rv_fwhm_2d(_rv, pixel_bconv).T\n            span_bconv = 0.0\n            rv_tot, fwhm_tot = compute_rv_fwhm_2d(_rv, pixel_tot).T\n            span_tot = 0.0\n        else:\n            _ = compute_rv_fwhm_bis_2d(_rv, pixel_flux).T\n            rv_flux, fwhm_flux, span_flux = _\n            _ = compute_rv_fwhm_bis_2d(_rv, pixel_bconv).T\n            rv_bconv, fwhm_bconv, span_bconv = _\n            _ = compute_rv_fwhm_bis_2d(_rv, pixel_tot).T\n            rv_tot, fwhm_tot, span_tot = _\n\n        depth_tot = None\n\n        if DEBUG:\n            print(\"finished map(bis), took %f sec\" % (time.time() - t1))\n\n    else:\n        if self.verbose:\n            print(\"Computing CCFs for each spectra\")\n        _rv= np.arange(-20, 20 + 0.5, 0.5)\n        _precompile_gauss(_rv)\n\n        t1 = time.time()\n        if template:\n            ccf_pixel_flux = np.array(\n                [\n                    stspnumba.calculate_ccf(\n                        template[\"wave\"], template[\"flux\"], self.pixel.wave, i\n                    )[1]\n                    for i in pixel_flux\n                ]\n            )\n        else:\n            ccf_pixel_flux = np.array(\n                [\n                    stspnumba.calculate_ccf(\n                        self.pixel.wave, self.pixel.flux, self.pixel.wave, i\n                    )[1]\n                    for i in pixel_flux\n                ]\n            )\n\n        if DEBUG:\n            print(\"I am in line 965\")\n            plt.plot(_rv, ccf_pixel_flux.T)\n            plt.show()\n\n        _ = self.get_results(_rv, ccf_pixel_flux, skip_fwhm, skip_bis)\n        rv_flux, fwhm_flux, span_flux = _\n        if template:\n            ccf_pixel_bconv = np.array(\n                [\n                    stspnumba.calculate_ccf(\n                        template[\"wave\"], template[\"flux\"], self.pixel.wave, i\n                    )[1]\n                    for i in pixel_bconv\n                ]\n            )\n        else:\n            ccf_pixel_bconv = np.array(\n                [\n                    stspnumba.calculate_ccf(\n                        self.pixel.wave, self.pixel.flux, self.pixel.wave, i\n                    )[1]\n                    for i in pixel_bconv\n                ]\n            )\n\n        _ = self.get_results(_rv, ccf_pixel_bconv, skip_fwhm, skip_bis)\n        rv_bconv, fwhm_bconv, span_bconv = _\n        if template:\n            ccf_pixel_tot = np.array(\n                [\n                    stspnumba.calculate_ccf(\n                        template[\"wave\"], template[\"flux\"], self.pixel.wave, i\n                    )[1]\n                    for i in pixel_tot\n                ]\n            )\n        else:\n            ccf_pixel_tot = np.array(\n                [\n                    stspnumba.calculate_ccf(\n                        self.pixel.wave, self.pixel.flux, self.pixel.wave, i\n                    )[1]\n                    for i in pixel_tot\n                ]\n            )\n        self.ccf=ccf_pixel_tot\n        self.rv=_rv\n        _ = self.get_results(_rv, ccf_pixel_tot, skip_fwhm, skip_bis)\n        rv_tot, fwhm_tot, span_tot = _\n        if DEBUG:\n            plt.plot(rv_tot)\n            plt.show()\n        depth_tot = None\n\n        if DEBUG:\n            print(\"finished map(bis), took %f sec\" % (time.time() - t1))\n\n    if renormalize_rv:\n        # find where rv_flux = rv_bconv, which corresponds to the phases\n        # where the active regions are not visible\n        index_equal_rv = np.where((rv_flux - rv_bconv) == 0)[0]\n        if len(index_equal_rv) != 0:\n            # velocity when the spot is not visible\n            zero_velocity = rv_flux[index_equal_rv][0]\n            # set velocity when the active region is not visible to 0\n            rv_flux -= zero_velocity\n            rv_bconv -= zero_velocity\n            rv_tot -= zero_velocity\n            if not skip_fwhm:\n                # FWHM when the spot is not visible\n                zero_fw = fwhm_flux[index_equal_rv][0]\n                # set FWHM when the active region is not visible to 0\n                fwhm_flux -= zero_fw\n                fwhm_bconv -= zero_fw\n                fwhm_tot -= zero_fw\n            if not skip_bis:\n                # BIS when the spot is not visible\n                zero_bis = span_flux[index_equal_rv][0]\n                # set FWHM when the active region is not visible to 0\n                span_flux -= zero_bis\n                span_bconv -= zero_bis\n                span_tot -= zero_bis\n    self.integrated_spectra = self.pixel_tot\n    ###################\n    if self.has_planet:\n\n        tr_dur = (\n            1.0\n            / np.pi\n            * np.arcsin(\n                1.0\n                / (self.planet.a).value\n                * np.sqrt(\n                    (1 + (self.planet.Rp).value) ** 2.0\n                    - (self.planet.a).value ** 2.0\n                    * np.cos(np.radians((self.planet.ip).value)) ** 2.0\n                )\n            )\n        )\n        try:\n            planet_phases = psi * self.star.prot / self.planet.P\n            phase_mask = np.logical_or(\n                planet_phases &lt; -tr_dur / 2, planet_phases &gt; tr_dur / 2\n            )\n            # Note: There is not effect of the keplerian here, so everything is in the stellar rest-frame unless we have \n            # a AR\n            rv_tot_out = rv_tot[phase_mask]\n            psi_out = planet_phases[phase_mask]\n\n            slope_coefs = np.polyfit(psi_out, rv_tot_out, deg=1)\n\n            slope_rvs = slope_coefs[0] * planet_phases + slope_coefs[1]\n\n            if DEBUG == True:\n                print(\"Slopes coefficients out-of-transit\")\n                print(slope_coefs)\n                print(\"RVs out-of-transit\")\n                print(rv_tot_out)\n                print(\"RVs obtained from a linear fit from the out-of-transit\")\n                print(slope_rvs)\n\n            corr_pixel_flux = np.array(\n                [\n                    stspnumba.doppler_shift(pixel.wave, pixel_tot[i], -slope_rvs[i])\n                    for i in range(len(pixel_tot))\n                ]\n            )\n\n            # Carefull! When we have an active region, the master out does not correspond to pflux, the user must make it manually!\n            flux_weighted_spectra = np.array(\n                [\n                    corr_pixel_flux[j] * FLUXstar[j]\n                    for j in range(len(corr_pixel_flux))\n                ]\n            )\n            self.master_out_fw = np.mean(flux_weighted_spectra[phase_mask], axis=0)\n            self.integrated_spectra_fw = flux_weighted_spectra\n\n            master_out = np.mean(corr_pixel_flux[phase_mask], axis=0)\n            self.pixel_trans = corr_pixel_flux / master_out\n            self.integrated_spectra = corr_pixel_flux\n        except:\n            None\n\n    ###################\n    # put back the units (with in-place conversion, avoiding copies)\n    rv_flux &lt;&lt;= self.pixel._rv_units\n    rv_bconv &lt;&lt;= self.pixel._rv_units\n    rv_tot &lt;&lt;= self.pixel._rv_units\n    if not skip_fwhm:\n        fwhm_flux &lt;&lt;= self.pixel._rv_units\n        fwhm_bconv &lt;&lt;= self.pixel._rv_units\n        fwhm_tot &lt;&lt;= self.pixel._rv_units\n    if not skip_bis:\n        span_flux &lt;&lt;= self.pixel._rv_units\n        span_bconv &lt;&lt;= self.pixel._rv_units\n        span_tot &lt;&lt;= self.pixel._rv_units\n\n    if self.has_planet:\n        rv_kep = self.planet.rv_curve(psi * star.prot, stellar_mass=star.mass)\n\n        if not self._ccf_mode:\n            # shift by the Keplerian RV\n            for i in range(pixel_tot.shape[0]):\n                pixel_tot[i] = stspnumba.doppler_shift(\n                    pixel.wave, pixel_tot[i], rv_kep[i].value\n                )\n        else:\n            # shift by the Keplerian RV\n            for i in range(pixel_tot.shape[0]):\n                pixel_tot[i] = stspnumba.linear_interpolator(\n                    pixel.rv, pixel_tot[i], pixel.rv-rv_kep[i].value\n                )\n\n        # add Keplerian signal to final RVs\n        rv_tot += rv_kep\n\n    self.pixel_tot = pixel_tot\n\n    out = output(\n        psi=psi,\n        flux=FLUXstar,\n        rv=rv_tot,\n        rv_bconv=rv_bconv,\n        rv_flux=rv_flux,\n        ccf_fwhm=fwhm_tot,\n        ccf_bis=span_tot,\n        ccf_depth=depth_tot,\n        itot_quiet=self.itot_pixel_quiet,\n        itot_flux=self.itot_flux_quiet,\n    )\n    return out\n</code></pre>"},{"location":"reference/#SOAP.Simulation.config_export","title":"<code>config_export(simVar='sim', show_all=False)</code>","text":"<p>Return list (as string) of all variables that can easily be re-imported.</p> Source code in <code>SOAP/SOAP.py</code> <pre><code>def config_export(self, simVar=\"sim\", show_all=False):\n    \"\"\"\n    Return list (as string) of all variables that can easily be re-imported.\n    \"\"\"\n\n    if type(simVar) is not str:\n        raise TypeError(\"simVar must be type 'str' not {}.\".format(type(simVar)))\n\n    outputstring = \"\"\n\n    # run over all of simulation's attributes\n    for key1 in self.__dict__.keys():\n\n        # skip some values\n        if not show_all:\n            if key1 in [\"ccf\", \"ccf_active_region\", \"itot_cached\", \"xyzplanet\"]:\n                continue\n\n        a1 = self.__getattribute__(key1)\n\n        # Object planet and star have second layer\n        if key1 in [\"planet\", \"star\"]:\n\n            if key1 == \"planet\":\n                outputstring += \"\\n# %s.has_planet = {}\".format(self.has_planet) % (\n                    simVar\n                )\n\n            for key2 in a1.__dict__.keys():\n\n                # skip some values\n                if not show_all:\n                    if key2 in [\"diffrotB\", \"diffrotC\", \"start_psi\", \"rad_sun\"]:\n                        continue\n\n                a2 = a1.__getattribute__(key2)\n\n                # ring has third layer\n                if key2 == \"ring\" and a2 is not None:\n                    outputstring += \"\\n\"\n                    outputstring += \"\\n# %s.planet.has_ring = {}\".format(\n                        self.planet.has_ring\n                    ) % (simVar)\n                    for key3 in a2.__dict__.keys():\n                        a3 = a2.__getattribute__(key3)\n                        outputstring += \"\\n%s.%s.%s.%s = {}\".format(a3) % (\n                            simVar,\n                            key1,\n                            key2,\n                            key3,\n                        )\n                else:\n                    outputstring += \"\\n%s.%s.%s = {}\".format(a2) % (\n                        simVar,\n                        key1,\n                        key2,\n                    )\n            outputstring += \"\\n\"\n\n        # active regions are list\n        elif key1 == \"active_regions\":\n            outputstring += \"\\n# %s.has_active_regions = {}\".format(\n                self.has_active_regions\n            ) % (simVar)\n            outputstring += \"\\n%s.active_regions = [\" % (simVar)\n            for ar in a1:\n                outputstring += (\n                    'SOAP.ActiveRegion(lon=%.9g,lat=%.9g,size=%.9g,active_region_type=\"%s\",check=%i),'\n                    % (ar.lon, ar.lat, ar.size, ar.type, ar.check)\n                )\n            outputstring += \"]\"\n            outputstring += \"\\n\"\n\n        # all other paramters (first layer)\n        else:\n            outputstring += \"\\n%s.%s = {}\".format(a1) % (simVar, key1)\n\n    # remove first linebreaks and add linebreak at end\n    while outputstring[0] == \"\\n\":\n        outputstring = outputstring[1:]\n    outputstring += \"\\n\"\n\n    return outputstring\n</code></pre>"},{"location":"reference/#SOAP.Simulation.run_itot","title":"<code>run_itot(skip_rv=False, cache=True)</code>","text":"<p>Calculate the CCF and the total flux for the quiet star</p> Source code in <code>SOAP/SOAP.py</code> <pre><code>def run_itot(self, skip_rv=False, cache=True):\n    \"\"\"Calculate the CCF and the total flux for the quiet star\"\"\"\n    if cache and self.itot_cached:\n        return self.pixel_quiet, self.flux_quiet\n\n    star = without_units(self.star)\n    if DEBUG:\n        t1 = time.time()\n    if self._ccf_mode:\n        pixel = without_units(self.pixel)\n        if skip_rv:\n            pixel_quiet = np.zeros(pixel.n_v)\n            flux_quiet = stspnumba.itot_flux(star.u1, star.u2, self.grid)\n        else:\n            pixel_quiet, flux_quiet = stspnumba.itot_rv(\n                star.vrot,\n                star.incl,\n                star.u1,\n                star.u2,\n                self.star.diffrotB,\n                self.star.diffrotC,\n                self.star.cb1,\n                self.grid,\n                pixel.rv,\n                pixel.intensity,\n                pixel.v_interval,\n                pixel.n_v,\n            )\n\n    else:\n        precompile_functions()\n        pixel = self.pixel.to_numba()\n        # pixel = without_units(self.pixel)\n        flux_quiet = stspnumba.itot_flux(star.u1, star.u2, self.grid)\n        pixel_quiet = stspnumba.itot_spectrum_par(\n            star.vrot,\n            star.incl,\n            star.u1,\n            star.u2,\n            self.star.diffrotB,\n            self.star.diffrotC,\n            self.star.cb1,\n            self.grid,\n            pixel,\n        )\n\n    if DEBUG:\n        print(\"finished itot, took %f sec\" % (time.time() - t1))\n        print(\"shape of pixel_quiet: %d\" % pixel_quiet.shape)\n        print(\"flux_quiet: %f\" % flux_quiet)\n\n    if cache:\n        self.itot_cached = True\n\n    self.pixel_quiet = pixel_quiet\n    self.flux_quiet = flux_quiet\n    return pixel_quiet, flux_quiet\n</code></pre>"},{"location":"reference/#SOAP.Simulation.set","title":"<code>set(**kwargs)</code>","text":"<p>Set (several) attributes of the simulation at once</p> Source code in <code>SOAP/SOAP.py</code> <pre><code>def set(self, **kwargs):\n    \"\"\"Set (several) attributes of the simulation at once\"\"\"\n    for k, v in kwargs.items():\n        try:\n            getattr(self, k)\n            setattr(self, k, v)\n        except AttributeError:\n            print(f'attribute \"{k}\" does not exist')\n</code></pre>"},{"location":"reference/#SOAP.Simulation.set_pixel","title":"<code>set_pixel(pixel, pixel_spot=None, pixel_plage=None)</code>","text":"<p>Set this simulation's pixel</p> <p>Parameters:</p> Name Type Description Default <code>pixel</code> <code>CCF or Spectrum</code> <p>The CCF or spectrum for each pixel in the quiet star</p> required <code>pixel_spot</code> <code>CCF or Spectrum</code> <p>The CCF for the spots</p> <code>None</code> <code>pixel_plage</code> <code>CCF or Spectrum</code> <p>The CCF for the plages</p> <code>None</code> Source code in <code>SOAP/SOAP.py</code> <pre><code>def set_pixel(self, pixel, pixel_spot=None, pixel_plage=None):\n    \"\"\"Set this simulation's pixel\n\n    Args:\n        pixel (SOAP.CCF or SOAP.Spectrum):\n            The CCF or spectrum for each pixel in the quiet star\n        pixel_spot (SOAP.CCF or SOAP.Spectrum):\n            The CCF for the spots\n        pixel_plage (SOAP.CCF or SOAP.Spectrum):\n            The CCF for the plages\n    \"\"\"\n    pixel.vrot = self.star.vrot\n    self.pixel = pixel\n\n    if pixel_spot is not None:\n        self.pixel_spot = copy(pixel_spot)\n    if pixel_plage is not None:\n        raise NotImplementedError(\"spots and plages use the same pixel\")\n\n    # force recalculation of itot\n    self.itot_cached = False\n    # connect CCFs with the star\n    self.star._pixel = self.pixel\n    self.star._pixel_spot = self.pixel_spot\n</code></pre>"},{"location":"reference/#SOAP.output","title":"<code>output</code>","text":"<p>A simple object to hold SOAP outputs</p> Source code in <code>SOAP/SOAP.py</code> <pre><code>class output:\n    \"\"\"A simple object to hold SOAP outputs\"\"\"\n\n    __slots__ = [\n        \"psi\",\n        \"flux\",\n        \"rv\",\n        \"rv_bconv\",\n        \"rv_flux\",\n        \"ccf_fwhm\",\n        \"ccf_bis\",\n        \"ccf_depth\",\n        \"itot_quiet\",\n        \"itot_flux\",\n    ]\n\n    def __init__(self, **kwargs):\n        # set defaults\n        for attr in self.__slots__:\n            setattr(self, attr, None)\n        # set from arguments\n        for attr, val in kwargs.items():\n            setattr(self, attr, val)\n\n    def plot(self, ms=False, ax=None, fig=None, label=None):\n        \"\"\"Make a simple plot of the quantities available in the output\"\"\"\n        import matplotlib.pyplot as plt\n\n        def get_label(name, arr=None):\n            try:\n                if arr is None:\n                    raise AttributeError\n                unit = f\"{arr.unit}\".replace(\" \", \"\")\n                if unit == \"\":\n                    raise AttributeError\n                return f\"{name} [{unit}]\"\n            except AttributeError:\n                return f\"{name}\"\n\n        if self.rv is None:\n            if ax is None and fig is None:\n                _, ax = plt.subplots(1, 1)\n            elif fig:\n                ax = fig.axes[0]\n            ax.plot(self.psi, self.flux, label=label)\n            ax.set(xlabel=\"rotation phase\", ylabel=get_label(\"flux\"))\n            if label is not None:\n                ax.legend()\n            return ax\n\n        else:\n            if ax is None and fig is None:\n                _, axs = plt.subplots(2, 2, constrained_layout=True)\n            elif fig:\n                axs = fig.axes\n                assert len(axs) == 4\n            else:\n                assert len(ax) == 4\n                axs = np.array(ax)\n\n            axs = np.ravel(axs)\n\n            flux = self.flux\n            if self.flux.size == 1:\n                flux = np.full_like(self.psi, self.flux)\n            axs[0].plot(self.psi, flux)\n            axs[0].set_ylabel(get_label(\"flux\", self.flux))\n\n            rv = self.rv.to(units.ms) if ms else self.rv\n            axs[1].plot(self.psi, rv)\n            axs[1].set_ylabel(get_label(\"RV\", rv))\n\n            if self.ccf_fwhm is not None:\n                fwhm = self.ccf_fwhm.to(units.ms) if ms else self.ccf_fwhm\n                axs[2].plot(self.psi, fwhm)\n                axs[2].set_ylabel(get_label(\"FWHM\", fwhm))\n            else:\n                axs[2].axis(\"off\")\n\n            if self.ccf_bis is not None:\n                bis = self.ccf_bis\n                axs[3].plot(self.psi, bis)\n                axs[3].set_ylabel(get_label(\"BIS\", bis))\n            else:\n                axs[3].axis(\"off\")\n\n            for ax in axs:\n                ax.set_xlabel(\"rotation phase\")\n\n        return axs\n\n    def change_units(self, new_units, quantity=\"all\"):\n        \"\"\"\n        Change units of some or all attribute.\n\n        Parameters\n        ----------\n        new_units : :class:`astropy.units.Unit`\n            The new units to convert the attribute(s) to.\n        quantity : str, optional, default 'all'\n            Which attribute for which to change units. By default, the function\n            changes all attributes which can be converted to `new_units`.\n        \"\"\"\n        if quantity == \"all\":  # try to change all units\n            for attr in self.__slots__:\n                try:\n                    setattr(self, attr, getattr(self, attr).to(new_units))\n                except (U.UnitConversionError, AttributeError):\n                    pass\n\n        else:  # or just try to change one\n            try:\n                setattr(self, quantity, getattr(self, quantity).to(new_units))\n            except AttributeError:\n                msg = (\n                    f\"'{quantity}' is not an attribute \"\n                    f\"or cannot be converted to {new_units}\"\n                )\n                raise U.UnitConversionError(msg) from None\n\n    def set_units(self, units, quantity):\n        \"\"\"\n        Set the units of a given attribute. Note that this function *resets* the\n        units if they already exist. To change units use change_units()\n\n        Parameters\n        ----------\n        units : :class:`astropy.units.Unit`\n            The units to set the attribute to.\n        quantity : str\n            Which attribute to set the units.\n        \"\"\"\n        # does the attribute exist?\n        if not hasattr(self, quantity):\n            raise AttributeError(f\"'{quantity}' is not an attribute\")\n\n        try:\n            temp = getattr(self, quantity).value * units\n            setattr(self, quantity, temp)\n        except AttributeError:\n            temp = getattr(self, quantity) * units\n            setattr(self, quantity, temp)\n\n    # Warning! We are not saving the spectra yet\n    def save_rdb(\n        self,\n        filename,\n        prot=None,\n        simulate_errors=False,\n        typical_error_rv=0.8 * units.ms,\n    ):\n        header = \"bjd\\tvrad\\tsvrad\\tfwhm\\tsfwhm\\n\"\n        header += \"---\\t----\\t-----\\t----\\t-----\"\n        fmt = [\"%-9.5f\"] + 4 * [\"%-7.3f\"]\n\n        # ptp = self.rv.value.ptp()\n        # rv_err = np.random.uniform(0.1 * ptp, 0.2 * ptp, size=self.rv.size)\n        # ptp = self.ccf_fwhm.value.ptp()\n        # fw_err = np.random.uniform(0.1 * ptp, 0.2 * ptp, size=self.rv.size)\n        n = self.rv.size\n        e = typical_error_rv.value\n        rv_err = np.random.uniform(0.9 * e, 1.1 * e, size=n)\n        fw_err = np.random.uniform(2 * 0.9 * e, 2 * 1.1 * e, size=n)\n\n        if simulate_errors:\n            rv = self.rv.value + np.random.normal(np.zeros(n), rv_err)\n            fw = self.ccf_fwhm.value + np.random.normal(np.zeros(n), fw_err)\n        else:\n            rv = self.rv.value\n            fw = self.ccf_fwhm.value\n\n        if prot is None:\n            psi = self.psi\n        else:\n            psi = self.psi * prot\n\n        data = np.c_[psi, rv, rv_err, fw, fw_err]\n\n        np.savetxt(filename, data, header=header, fmt=fmt, comments=\"\", delimiter=\"\\t\")\n</code></pre>"},{"location":"reference/#SOAP.output.change_units","title":"<code>change_units(new_units, quantity='all')</code>","text":"<p>Change units of some or all attribute.</p>"},{"location":"reference/#SOAP.output.change_units--parameters","title":"Parameters","text":"<p>new_units : :class:<code>astropy.units.Unit</code>     The new units to convert the attribute(s) to. quantity : str, optional, default 'all'     Which attribute for which to change units. By default, the function     changes all attributes which can be converted to <code>new_units</code>.</p> Source code in <code>SOAP/SOAP.py</code> <pre><code>def change_units(self, new_units, quantity=\"all\"):\n    \"\"\"\n    Change units of some or all attribute.\n\n    Parameters\n    ----------\n    new_units : :class:`astropy.units.Unit`\n        The new units to convert the attribute(s) to.\n    quantity : str, optional, default 'all'\n        Which attribute for which to change units. By default, the function\n        changes all attributes which can be converted to `new_units`.\n    \"\"\"\n    if quantity == \"all\":  # try to change all units\n        for attr in self.__slots__:\n            try:\n                setattr(self, attr, getattr(self, attr).to(new_units))\n            except (U.UnitConversionError, AttributeError):\n                pass\n\n    else:  # or just try to change one\n        try:\n            setattr(self, quantity, getattr(self, quantity).to(new_units))\n        except AttributeError:\n            msg = (\n                f\"'{quantity}' is not an attribute \"\n                f\"or cannot be converted to {new_units}\"\n            )\n            raise U.UnitConversionError(msg) from None\n</code></pre>"},{"location":"reference/#SOAP.output.plot","title":"<code>plot(ms=False, ax=None, fig=None, label=None)</code>","text":"<p>Make a simple plot of the quantities available in the output</p> Source code in <code>SOAP/SOAP.py</code> <pre><code>def plot(self, ms=False, ax=None, fig=None, label=None):\n    \"\"\"Make a simple plot of the quantities available in the output\"\"\"\n    import matplotlib.pyplot as plt\n\n    def get_label(name, arr=None):\n        try:\n            if arr is None:\n                raise AttributeError\n            unit = f\"{arr.unit}\".replace(\" \", \"\")\n            if unit == \"\":\n                raise AttributeError\n            return f\"{name} [{unit}]\"\n        except AttributeError:\n            return f\"{name}\"\n\n    if self.rv is None:\n        if ax is None and fig is None:\n            _, ax = plt.subplots(1, 1)\n        elif fig:\n            ax = fig.axes[0]\n        ax.plot(self.psi, self.flux, label=label)\n        ax.set(xlabel=\"rotation phase\", ylabel=get_label(\"flux\"))\n        if label is not None:\n            ax.legend()\n        return ax\n\n    else:\n        if ax is None and fig is None:\n            _, axs = plt.subplots(2, 2, constrained_layout=True)\n        elif fig:\n            axs = fig.axes\n            assert len(axs) == 4\n        else:\n            assert len(ax) == 4\n            axs = np.array(ax)\n\n        axs = np.ravel(axs)\n\n        flux = self.flux\n        if self.flux.size == 1:\n            flux = np.full_like(self.psi, self.flux)\n        axs[0].plot(self.psi, flux)\n        axs[0].set_ylabel(get_label(\"flux\", self.flux))\n\n        rv = self.rv.to(units.ms) if ms else self.rv\n        axs[1].plot(self.psi, rv)\n        axs[1].set_ylabel(get_label(\"RV\", rv))\n\n        if self.ccf_fwhm is not None:\n            fwhm = self.ccf_fwhm.to(units.ms) if ms else self.ccf_fwhm\n            axs[2].plot(self.psi, fwhm)\n            axs[2].set_ylabel(get_label(\"FWHM\", fwhm))\n        else:\n            axs[2].axis(\"off\")\n\n        if self.ccf_bis is not None:\n            bis = self.ccf_bis\n            axs[3].plot(self.psi, bis)\n            axs[3].set_ylabel(get_label(\"BIS\", bis))\n        else:\n            axs[3].axis(\"off\")\n\n        for ax in axs:\n            ax.set_xlabel(\"rotation phase\")\n\n    return axs\n</code></pre>"},{"location":"reference/#SOAP.output.set_units","title":"<code>set_units(units, quantity)</code>","text":"<p>Set the units of a given attribute. Note that this function resets the units if they already exist. To change units use change_units()</p>"},{"location":"reference/#SOAP.output.set_units--parameters","title":"Parameters","text":"<p>units : :class:<code>astropy.units.Unit</code>     The units to set the attribute to. quantity : str     Which attribute to set the units.</p> Source code in <code>SOAP/SOAP.py</code> <pre><code>def set_units(self, units, quantity):\n    \"\"\"\n    Set the units of a given attribute. Note that this function *resets* the\n    units if they already exist. To change units use change_units()\n\n    Parameters\n    ----------\n    units : :class:`astropy.units.Unit`\n        The units to set the attribute to.\n    quantity : str\n        Which attribute to set the units.\n    \"\"\"\n    # does the attribute exist?\n    if not hasattr(self, quantity):\n        raise AttributeError(f\"'{quantity}' is not an attribute\")\n\n    try:\n        temp = getattr(self, quantity).value * units\n        setattr(self, quantity, temp)\n    except AttributeError:\n        temp = getattr(self, quantity) * units\n        setattr(self, quantity, temp)\n</code></pre>"},{"location":"notebooks/RV_phot_AR_crossing/","title":"Transit photometry and RV of a AR-crossing event","text":"<p>In this notebook, we simulate a Sun-like star orbited by a Jupiter-like planet and compute the expected transit light curve and radial velocity (RV) time series using the standard QS FTS CCF method. We also introduce a central AR with a radius equal to 10% of the stellar radius and a temperature contrast of 600\u202fK, positive for the facula and negative for the spot.</p> In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom SOAP.visualizer import plot_absorption_map\nfrom SOAP.utils import transit_durations\nimport SOAP\nfrom IPython.display import HTML\n</pre> import numpy as np import matplotlib.pyplot as plt from SOAP.visualizer import plot_absorption_map from SOAP.utils import transit_durations import SOAP from IPython.display import HTML In\u00a0[2]: Copied! <pre># Star-like star, rigid rotation\nradius=1                # Stellar radius [solar radii]\nmass=1                  # Stellar mass [solar masses]\nprot=24.47              # Stellar rotation period [days]\nincl=90                 # Stellar inclination [degrees] -&gt; 90 is equator-on, 0 is pole-on\nlogg= 4.4               # Stellar surface gravity [cgs]\nfeh= 0.00               # Stellar metallicity [dex]\nTeff=5777               # Stellar effective temperature [K]\nldcn=[[0.5,0.16]]       # Linear and quadratic limb-darkening coefficients\nstart_psi=0.0           # Starting phase of the star\n\n# Mock jupiter-like planet close to the star\nPp=3                    # Orbital period [days]\ne=0.0                   # Orbital eccentricity\nw=90.0                  # Argument of periastron [degrees]\nip=90                   # Orbital inclination [degrees]\nlbda=0                  # Sky-projected spin-orbit misalignement [degrees]\na=9                     # Semi-major axis [stellar radii]\nRp=0.15                 # Planetary radius [stellar radii]\nMp=317.8                # Planetary mass [Earth masses]\n\n# Observational parameters\n\u03bb =[5882, 5902]         # Wavelength range [Angstrom]\nRes=140000              # Instrumental resolution\n</pre> # Star-like star, rigid rotation radius=1                # Stellar radius [solar radii] mass=1                  # Stellar mass [solar masses] prot=24.47              # Stellar rotation period [days] incl=90                 # Stellar inclination [degrees] -&gt; 90 is equator-on, 0 is pole-on logg= 4.4               # Stellar surface gravity [cgs] feh= 0.00               # Stellar metallicity [dex] Teff=5777               # Stellar effective temperature [K] ldcn=[[0.5,0.16]]       # Linear and quadratic limb-darkening coefficients start_psi=0.0           # Starting phase of the star  # Mock jupiter-like planet close to the star Pp=3                    # Orbital period [days] e=0.0                   # Orbital eccentricity w=90.0                  # Argument of periastron [degrees] ip=90                   # Orbital inclination [degrees] lbda=0                  # Sky-projected spin-orbit misalignement [degrees] a=9                     # Semi-major axis [stellar radii] Rp=0.15                 # Planetary radius [stellar radii] Mp=317.8                # Planetary mass [Earth masses]  # Observational parameters \u03bb =[5882, 5902]         # Wavelength range [Angstrom] Res=140000              # Instrumental resolution In\u00a0[3]: Copied! <pre>sim = SOAP.Simulation(wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=Res, grid=600, ring=None)\n</pre> sim = SOAP.Simulation(wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=Res, grid=600, ring=None) In\u00a0[4]: Copied! <pre>sim.active_regions=[SOAP.ActiveRegion(check = True,\n                             lon = 0,\n                             lat = 0,\n                             size = 0.1 ,\n                             temp_diff = 600, # in K, this is the default value\n                             active_region_type = 0\n                            )]\n</pre> sim.active_regions=[SOAP.ActiveRegion(check = True,                              lon = 0,                              lat = 0,                              size = 0.1 ,                              temp_diff = 600, # in K, this is the default value                              active_region_type = 0                             )] In\u00a0[5]: Copied! <pre># Set the properties of the star and planet\nsim.star.set(prot=prot,incl=incl,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff)\nsim.planet.set(P=Pp,t0=start_psi,e=e,w=w,ip=ip,lbda=lbda,a=a,Rp=Rp,Mp=Mp)\n</pre> # Set the properties of the star and planet sim.star.set(prot=prot,incl=incl,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff) sim.planet.set(P=Pp,t0=start_psi,e=e,w=w,ip=ip,lbda=lbda,a=a,Rp=Rp,Mp=Mp) In\u00a0[6]: Copied! <pre># Provide the range of stellar phases to simulate\npsi = np.linspace(-0.1,0.1,50) / sim.star.prot\n</pre> # Provide the range of stellar phases to simulate psi = np.linspace(-0.1,0.1,50) / sim.star.prot In\u00a0[7]: Copied! <pre># Calculate the transit signal\nout=sim.calculate_signal(psi, renormalize_rv=True)\n</pre> # Calculate the transit signal out=sim.calculate_signal(psi, renormalize_rv=True) In\u00a0[8]: Copied! <pre>tr_dur,tr_ingress_egress=transit_durations(sim)\ntr_dur*=sim.planet.P.value*24  # in hours\ntr_ingress_egress*=sim.planet.P.value*24  # in hours\n</pre> tr_dur,tr_ingress_egress=transit_durations(sim) tr_dur*=sim.planet.P.value*24  # in hours tr_ingress_egress*=sim.planet.P.value*24  # in hours In\u00a0[9]: Copied! <pre>sim.active_regions[0].temp_diff.value\n</pre> sim.active_regions[0].temp_diff.value Out[9]: <pre>np.float64(600.0)</pre> In\u00a0[10]: Copied! <pre>sim.visualize(\n    output=out,\n    plot_type=\"flux\",\n)\n</pre> sim.visualize(     output=out,     plot_type=\"flux\", ) In\u00a0[11]: Copied! <pre>sim.visualize(\n    output=out,\n    plot_type=\"rv\"\n)\n</pre> sim.visualize(     output=out,     plot_type=\"rv\" ) In\u00a0[12]: Copied! <pre>sim.active_regions=[SOAP.ActiveRegion(check = True,\n                             lon = 0,\n                             lat = 0,\n                             size = 0.1 ,\n                             temp_diff = 600, # in K, this is the default value\n                             active_region_type = 1\n                            )]\n</pre> sim.active_regions=[SOAP.ActiveRegion(check = True,                              lon = 0,                              lat = 0,                              size = 0.1 ,                              temp_diff = 600, # in K, this is the default value                              active_region_type = 1                             )] In\u00a0[13]: Copied! <pre>out=sim.calculate_signal(psi, renormalize_rv=True)\n</pre> out=sim.calculate_signal(psi, renormalize_rv=True) In\u00a0[14]: Copied! <pre>sim.visualize(\n    output=out,\n    plot_type=\"flux\",\n)\n</pre> sim.visualize(     output=out,     plot_type=\"flux\", ) In\u00a0[15]: Copied! <pre>sim.visualize(\n    output=out,\n    plot_type=\"rv\",\n)\n</pre> sim.visualize(     output=out,     plot_type=\"rv\", )"},{"location":"notebooks/RV_phot_AR_crossing/#transit-photometry-and-rv-of-a-ar-crossing-event","title":"Transit photometry and RV of a AR-crossing event\u00b6","text":""},{"location":"notebooks/RV_phot_AR_crossing/#start-the-simulation","title":"Start the simulation\u00b6","text":""},{"location":"notebooks/RV_phot_AR_crossing/#plot-the-results","title":"Plot the results\u00b6","text":""},{"location":"notebooks/RV_phot_activity/","title":"RV and Photometry time-series in the presence of stellar activity","text":"<p>In this notebook, we model a Sun-like star featuring both spots and faculae over a full stellar rotation. Using these simulations, we generate the corresponding photometric light curve and radial velocity time series, computed via the standard QS FTS CCF method.</p> In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom SOAP.visualizer import plot_absorption_map\nfrom SOAP.utils import transit_durations\nimport SOAP\nfrom IPython.display import HTML\n</pre> import numpy as np import matplotlib.pyplot as plt from SOAP.visualizer import plot_absorption_map from SOAP.utils import transit_durations import SOAP from IPython.display import HTML In\u00a0[2]: Copied! <pre># Star-like star, rigid rotation\nradius=1                # Stellar radius [solar radii]\nmass=1                  # Stellar mass [solar masses]\nprot=24.47              # Stellar rotation period [days]\nincl=45                 # Stellar inclination [degrees] -&gt; 90 is equator-on, 0 is pole-on\nlogg= 4.4               # Stellar surface gravity [cgs]\nfeh= 0.00               # Stellar metallicity [dex]\nTeff=5777               # Stellar effective temperature [K]\nldcn=[[0.5,0.16]]       # Linear and quadratic limb-darkening coefficients (must agree with \u03bb, see below)\nstart_psi=0.0           # Starting phase of the star\n\n# Observational parameters\n\u03bb =[3782, 7887]         # Wavelength range [Angstrom]\nRes=140000              # Instrumental resolution\n</pre> # Star-like star, rigid rotation radius=1                # Stellar radius [solar radii] mass=1                  # Stellar mass [solar masses] prot=24.47              # Stellar rotation period [days] incl=45                 # Stellar inclination [degrees] -&gt; 90 is equator-on, 0 is pole-on logg= 4.4               # Stellar surface gravity [cgs] feh= 0.00               # Stellar metallicity [dex] Teff=5777               # Stellar effective temperature [K] ldcn=[[0.5,0.16]]       # Linear and quadratic limb-darkening coefficients (must agree with \u03bb, see below) start_psi=0.0           # Starting phase of the star  # Observational parameters \u03bb =[3782, 7887]         # Wavelength range [Angstrom] Res=140000              # Instrumental resolution In\u00a0[3]: Copied! <pre>sim = SOAP.Simulation(wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=Res, grid=600)\n</pre> sim = SOAP.Simulation(wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=Res, grid=600) In\u00a0[4]: Copied! <pre># Add the active regions to the simulation\n\nsim.active_regions=[SOAP.ActiveRegion(check=True, lon=-41.957, lat=22.092, size=0.084, temp_diff=600, active_region_type=0),\nSOAP.ActiveRegion(check=True, lon=152.158, lat=24.510, size=0.0198, temp_diff=600, active_region_type=0),\nSOAP.ActiveRegion(check=True, lon=-136.858, lat=-6.387, size=0.0116, temp_diff=600, active_region_type=0),\nSOAP.ActiveRegion(check=True, lon=-128.928, lat=-21.913, size=0.0280, temp_diff=600, active_region_type=0),\nSOAP.ActiveRegion(check=True, lon=82.256, lat=-12.097, size=0.0101, temp_diff=600, active_region_type=0),\nSOAP.ActiveRegion(check=True, lon=33.596, lat=-25.118, size=0.0344, temp_diff=300, active_region_type=1),\nSOAP.ActiveRegion(check=True, lon=-102.713, lat=-4.079, size=0.0175, temp_diff=300, active_region_type=1),\nSOAP.ActiveRegion(check=True, lon=133.568, lat=15.191, size=0.0232, temp_diff=300, active_region_type=1),\nSOAP.ActiveRegion(check=True, lon=163.813, lat=14.113, size=0.0112, temp_diff=300, active_region_type=1),\nSOAP.ActiveRegion(check=True, lon=176.567, lat=-27.145, size=0.0101, temp_diff=300, active_region_type=1)]\n</pre> # Add the active regions to the simulation  sim.active_regions=[SOAP.ActiveRegion(check=True, lon=-41.957, lat=22.092, size=0.084, temp_diff=600, active_region_type=0), SOAP.ActiveRegion(check=True, lon=152.158, lat=24.510, size=0.0198, temp_diff=600, active_region_type=0), SOAP.ActiveRegion(check=True, lon=-136.858, lat=-6.387, size=0.0116, temp_diff=600, active_region_type=0), SOAP.ActiveRegion(check=True, lon=-128.928, lat=-21.913, size=0.0280, temp_diff=600, active_region_type=0), SOAP.ActiveRegion(check=True, lon=82.256, lat=-12.097, size=0.0101, temp_diff=600, active_region_type=0), SOAP.ActiveRegion(check=True, lon=33.596, lat=-25.118, size=0.0344, temp_diff=300, active_region_type=1), SOAP.ActiveRegion(check=True, lon=-102.713, lat=-4.079, size=0.0175, temp_diff=300, active_region_type=1), SOAP.ActiveRegion(check=True, lon=133.568, lat=15.191, size=0.0232, temp_diff=300, active_region_type=1), SOAP.ActiveRegion(check=True, lon=163.813, lat=14.113, size=0.0112, temp_diff=300, active_region_type=1), SOAP.ActiveRegion(check=True, lon=176.567, lat=-27.145, size=0.0101, temp_diff=300, active_region_type=1)] In\u00a0[5]: Copied! <pre># Set the properties of the star\nsim.star.set(prot=prot,incl=incl,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff)\n\n# Deactivate the planet\nsim.planet.Rp=0\n</pre> # Set the properties of the star sim.star.set(prot=prot,incl=incl,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff)  # Deactivate the planet sim.planet.Rp=0 In\u00a0[6]: Copied! <pre># Provide the range of stellar phases to simulate\npsi = np.linspace(0,1,100)\n</pre> # Provide the range of stellar phases to simulate psi = np.linspace(0,1,100) In\u00a0[7]: Copied! <pre># Calculate the RV and photometric time series\nout=sim.calculate_signal(psi, renormalize_rv=True)\n</pre> # Calculate the RV and photometric time series out=sim.calculate_signal(psi, renormalize_rv=True) In\u00a0[8]: Copied! <pre># Create an animation of the flux variation\nani = sim.visualize_animation(\n    output=out,\n    plot_type=\"flux\"\n)\nHTML(ani.to_jshtml())\n</pre> # Create an animation of the flux variation ani = sim.visualize_animation(     output=out,     plot_type=\"flux\" ) HTML(ani.to_jshtml()) Out[8]: Once Loop Reflect In\u00a0[9]: Copied! <pre># Create an animation of the RV variation\nani = sim.visualize_animation(\n    output=out,\n    plot_type=\"rv\"\n)\nHTML(ani.to_jshtml())\n</pre> # Create an animation of the RV variation ani = sim.visualize_animation(     output=out,     plot_type=\"rv\" ) HTML(ani.to_jshtml()) Out[9]: Once Loop Reflect"},{"location":"notebooks/RV_phot_activity/#rv-and-photometry-time-series-in-the-presence-of-stellar-activity","title":"RV and Photometry time-series in the presence of stellar activity\u00b6","text":""},{"location":"notebooks/RV_phot_activity/#start-the-simulation","title":"Start the simulation\u00b6","text":""},{"location":"notebooks/RV_phot_activity/#plot-the-results","title":"Plot the results\u00b6","text":""},{"location":"notebooks/RV_phot_transit/","title":"Transit photometry and RV","text":"<p>In this notebook, we simulate a Sun-like star hosting a Jupiter-like planet, and compute the expected transit light curve and RV time series (standard QS FTS CCF).</p> In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom SOAP.visualizer import plot_absorption_map\nfrom SOAP.utils import transit_durations\nimport SOAP\nfrom IPython.display import HTML\n</pre> import numpy as np import matplotlib.pyplot as plt from SOAP.visualizer import plot_absorption_map from SOAP.utils import transit_durations import SOAP from IPython.display import HTML In\u00a0[2]: Copied! <pre># Star-like star, rigid rotation\nradius=1                # Stellar radius [solar radii]\nmass=1                  # Stellar mass [solar masses]\nprot=24.47              # Stellar rotation period [days]\nincl=45                 # Stellar inclination [degrees] -&gt; 90 is equator-on, 0 is pole-on\nlogg= 4.4               # Stellar surface gravity [cgs]\nfeh= 0.00               # Stellar metallicity [dex]\nTeff=5777               # Stellar effective temperature [K]\nldcn=[[0.5,0.16]]       # Linear and quadratic limb-darkening coefficients\nstart_psi=0.0           # Starting phase of the star\n\n# Mock jupiter-like planet close to the star\nPp=3                    # Orbital period [days]\ne=0.0                   # Orbital eccentricity\nw=90.0                  # Argument of periastron [degrees]\nip=90                   # Orbital inclination [degrees]\nlbda=0                  # Sky-projected spin-orbit misalignement [degrees]\na=9                     # Semi-major axis [stellar radii]\nRp=0.15                 # Planetary radius [stellar radii]\nMp=317.8                # Planetary mass [Earth masses]\n\n# Observational parameters\n\u03bb =[5882, 5902]         # Wavelength range [Angstrom]\nRes=140000              # Instrumental resolution\n</pre> # Star-like star, rigid rotation radius=1                # Stellar radius [solar radii] mass=1                  # Stellar mass [solar masses] prot=24.47              # Stellar rotation period [days] incl=45                 # Stellar inclination [degrees] -&gt; 90 is equator-on, 0 is pole-on logg= 4.4               # Stellar surface gravity [cgs] feh= 0.00               # Stellar metallicity [dex] Teff=5777               # Stellar effective temperature [K] ldcn=[[0.5,0.16]]       # Linear and quadratic limb-darkening coefficients start_psi=0.0           # Starting phase of the star  # Mock jupiter-like planet close to the star Pp=3                    # Orbital period [days] e=0.0                   # Orbital eccentricity w=90.0                  # Argument of periastron [degrees] ip=90                   # Orbital inclination [degrees] lbda=0                  # Sky-projected spin-orbit misalignement [degrees] a=9                     # Semi-major axis [stellar radii] Rp=0.15                 # Planetary radius [stellar radii] Mp=317.8                # Planetary mass [Earth masses]  # Observational parameters \u03bb =[5882, 5902]         # Wavelength range [Angstrom] Res=140000              # Instrumental resolution In\u00a0[3]: Copied! <pre>sim = SOAP.Simulation(wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=Res, grid=600, active_regions=[], ring=None)\n</pre> sim = SOAP.Simulation(wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=Res, grid=600, active_regions=[], ring=None) In\u00a0[4]: Copied! <pre># Set the properties of the star and planet\nsim.star.set(prot=prot,incl=incl,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff)\nsim.planet.set(P=Pp,t0=start_psi,e=e,w=w,ip=ip,lbda=lbda,a=a,Rp=Rp,Mp=Mp)\n</pre> # Set the properties of the star and planet sim.star.set(prot=prot,incl=incl,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff) sim.planet.set(P=Pp,t0=start_psi,e=e,w=w,ip=ip,lbda=lbda,a=a,Rp=Rp,Mp=Mp) In\u00a0[5]: Copied! <pre># Provide the range of stellar phases to simulate\npsi = np.linspace(-0.1,0.1,50) / sim.star.prot\n</pre> # Provide the range of stellar phases to simulate psi = np.linspace(-0.1,0.1,50) / sim.star.prot In\u00a0[6]: Copied! <pre># Calculate the transit signal\nout=sim.calculate_signal(psi, renormalize_rv=True)\n</pre> # Calculate the transit signal out=sim.calculate_signal(psi, renormalize_rv=True) In\u00a0[7]: Copied! <pre>tr_dur,tr_ingress_egress=transit_durations(sim)\ntr_dur*=sim.planet.P.value*24  # in hours\ntr_ingress_egress*=sim.planet.P.value*24  # in hours\n</pre> tr_dur,tr_ingress_egress=transit_durations(sim) tr_dur*=sim.planet.P.value*24  # in hours tr_ingress_egress*=sim.planet.P.value*24  # in hours In\u00a0[10]: Copied! <pre>sim.visualize(\n    output=out,\n    plot_type=\"flux\",\n)\n</pre> sim.visualize(     output=out,     plot_type=\"flux\", ) In\u00a0[12]: Copied! <pre>sim.visualize(\n    output=out,\n    plot_type=\"rv\"\n)\n</pre> sim.visualize(     output=out,     plot_type=\"rv\" )"},{"location":"notebooks/RV_phot_transit/#transit-photometry-and-rv","title":"Transit photometry and RV\u00b6","text":""},{"location":"notebooks/RV_phot_transit/#start-the-simulation","title":"Start the simulation\u00b6","text":""},{"location":"notebooks/RV_phot_transit/#plot-the-results","title":"Plot the results\u00b6","text":""},{"location":"notebooks/Transit_time_series/","title":"Transit &amp; Absorption Time-Series","text":"<p>In this notebook, we simulate a Sun-like star hosting a Jupiter-sized planet, representing the stellar local spectra with a PHOENIX model. We compute a time series of spectra during the planetary transit within the wavelength range 5882\u20135902 \u00c5, and from these obtain the corresponding absorption time series in the stellar and planetary rest frames. We then illustrate the evolution of the absorption spectra as the planet moves across the stellar disk, culminating in the presentation of the resulting mean absorption spectrum.</p> In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.cm import ScalarMappable\nfrom matplotlib.colors import TwoSlopeNorm\nfrom SOAP.utils import transgrad, compute_planet_doppler_shift, transit_durations\nfrom SOAP.visualizer import plot_absorption_map\nimport SOAP\nfrom SOAP import PHOENIX\nfrom SOAP.fast_starspot import doppler_shift\nfrom astropy.constants import M_earth, M_sun\nfrom IPython.display import HTML\n</pre> import numpy as np import matplotlib.pyplot as plt from matplotlib.cm import ScalarMappable from matplotlib.colors import TwoSlopeNorm from SOAP.utils import transgrad, compute_planet_doppler_shift, transit_durations from SOAP.visualizer import plot_absorption_map import SOAP from SOAP import PHOENIX from SOAP.fast_starspot import doppler_shift from astropy.constants import M_earth, M_sun from IPython.display import HTML In\u00a0[2]: Copied! <pre># Star-like star, rigid rotation\nradius=1                # Stellar radius [solar radii]\nmass=1                  # Stellar mass [solar masses]\nprot=24.47              # Stellar rotation period [days]\nincl=45                 # Stellar inclination [degrees] -&gt; 90 is equator-on, 0 is pole-on\nlogg= 4.4               # Stellar surface gravity [cgs]\nfeh= 0.00               # Stellar metallicity [dex]\nTeff=5777               # Stellar effective temperature [K]\nldcn=[[0.5,0.16]]       # Linear and quadratic limb-darkening coefficients\nstart_psi=0.0           # Starting phase of the star\n\n# Mock jupiter-like planet close to the star\nPp=3                    # Orbital period [days]\ne=0.0                   # Orbital eccentricity\nw=90.0                  # Argument of periastron [degrees]\nip=90                   # Orbital inclination [degrees]\nlbda=0                  # Sky-projected spin-orbit misalignement [degrees]\na=9                     # Semi-major axis [stellar radii]\nRp=0.15                 # Planetary radius [stellar radii]\nMp=317.8                # Planetary mass [Earth masses]\n\n# Observational parameters\n\u03bb =[5882, 5902]         # Wavelength range [Angstrom]\nRes=140000              # Instrumental resolution\n</pre> # Star-like star, rigid rotation radius=1                # Stellar radius [solar radii] mass=1                  # Stellar mass [solar masses] prot=24.47              # Stellar rotation period [days] incl=45                 # Stellar inclination [degrees] -&gt; 90 is equator-on, 0 is pole-on logg= 4.4               # Stellar surface gravity [cgs] feh= 0.00               # Stellar metallicity [dex] Teff=5777               # Stellar effective temperature [K] ldcn=[[0.5,0.16]]       # Linear and quadratic limb-darkening coefficients start_psi=0.0           # Starting phase of the star  # Mock jupiter-like planet close to the star Pp=3                    # Orbital period [days] e=0.0                   # Orbital eccentricity w=90.0                  # Argument of periastron [degrees] ip=90                   # Orbital inclination [degrees] lbda=0                  # Sky-projected spin-orbit misalignement [degrees] a=9                     # Semi-major axis [stellar radii] Rp=0.15                 # Planetary radius [stellar radii] Mp=317.8                # Planetary mass [Earth masses]  # Observational parameters \u03bb =[5882, 5902]         # Wavelength range [Angstrom] Res=140000              # Instrumental resolution <p>Where we use will import Phoenix spectra that match the stellar properties. These will be used to compute the RVs in the simulation</p> In\u00a0[3]: Copied! <pre>spQ = PHOENIX(wave_range=\u03bb, normalize=True, teff=Teff, logg=logg, Z=feh)\ntplt={\"wave\":spQ.wave, \"flux\":spQ.flux} # Template spectrum matching the input local spectra to cumpute the RVs\n</pre> spQ = PHOENIX(wave_range=\u03bb, normalize=True, teff=Teff, logg=logg, Z=feh) tplt={\"wave\":spQ.wave, \"flux\":spQ.flux} # Template spectrum matching the input local spectra to cumpute the RVs In\u00a0[4]: Copied! <pre>sim = SOAP.Simulation(pixel=spQ, pixel_spot=None, wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=Res, grid=600, active_regions=[], ring=None)\n</pre> sim = SOAP.Simulation(pixel=spQ, pixel_spot=None, wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=Res, grid=600, active_regions=[], ring=None) In\u00a0[5]: Copied! <pre># Set the properties of the star and planet\nsim.star.set(prot=prot,incl=incl,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff)\nsim.planet.set(P=Pp,t0=start_psi,e=e,w=w,ip=ip,lbda=lbda,a=a,Rp=Rp,Mp=Mp)\n</pre> # Set the properties of the star and planet sim.star.set(prot=prot,incl=incl,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff) sim.planet.set(P=Pp,t0=start_psi,e=e,w=w,ip=ip,lbda=lbda,a=a,Rp=Rp,Mp=Mp) In\u00a0[6]: Copied! <pre># Provide the range of stellar phases to simulate\npsi = np.linspace(-0.1,0.1,50) / sim.star.prot\n</pre> # Provide the range of stellar phases to simulate psi = np.linspace(-0.1,0.1,50) / sim.star.prot In\u00a0[7]: Copied! <pre># Calculate the transit signal\nout=sim.calculate_signal(psi, renormalize_rv=True, template=tplt)\n</pre> # Calculate the transit signal out=sim.calculate_signal(psi, renormalize_rv=True, template=tplt) In\u00a0[8]: Copied! <pre># Convert from transmission to absorption [%]\nabsorption_spec=(1-sim.pixel_trans)*100\n</pre> # Convert from transmission to absorption [%] absorption_spec=(1-sim.pixel_trans)*100 In\u00a0[9]: Copied! <pre># Plot the absorption map in the stellar rest frame\nfig, ax = plot_absorption_map(sim,psi, absorption_spec,\u03bb)\nplt.show()\n</pre> # Plot the absorption map in the stellar rest frame fig, ax = plot_absorption_map(sim,psi, absorption_spec,\u03bb) plt.show()  In\u00a0[10]: Copied! <pre># Doppler shift of the map to the planetary rest frame\nabsorpt_prest=compute_planet_doppler_shift(sim,psi,absorption_spec)\n</pre> # Doppler shift of the map to the planetary rest frame absorpt_prest=compute_planet_doppler_shift(sim,psi,absorption_spec) In\u00a0[11]: Copied! <pre># Plot the absorption map in the planet rest frame\nfig, ax = plot_absorption_map(sim,psi,absorpt_prest,\u03bb)\nplt.show()\n</pre> # Plot the absorption map in the planet rest frame fig, ax = plot_absorption_map(sim,psi,absorpt_prest,\u03bb) plt.show() In\u00a0[12]: Copied! <pre># Create an animation of the transit with the absorption map\nani = sim.visualize_animation(\n    output=out,\n    plot_type=\"tr\",\n    lim=[5889.950-1.5, 5889.950+1.5],\n    ref_wave=5889.950,\n    plot_lims=[-1, 1]\n)\nHTML(ani.to_jshtml())\n</pre> # Create an animation of the transit with the absorption map ani = sim.visualize_animation(     output=out,     plot_type=\"tr\",     lim=[5889.950-1.5, 5889.950+1.5],     ref_wave=5889.950,     plot_lims=[-1, 1] ) HTML(ani.to_jshtml()) Out[12]: Once Loop Reflect"},{"location":"notebooks/Transit_time_series/#transit-absorption-time-series","title":"Transit &amp; Absorption Time-Series\u00b6","text":""},{"location":"notebooks/Transit_time_series/#start-the-simulation","title":"Start the simulation\u00b6","text":""},{"location":"notebooks/Transit_time_spot_crossing/","title":"Spot-Crossing Transit &amp; Absorption Time-Series","text":"<p>In this notebook, we simulate a Sun-like star hosting a Jupiter-sized planet, representing the stellar local spectra with a PHOENIX model. We compute a time series of spectra during the planetary transit within the wavelength range 5882\u20135902 \u00c5, and from these obtain the corresponding absorption time series in the stellar rest frame. We then illustrate the evolution of the absorption spectra as the planet moves across the stellar disk. In addition, we incorporate a central starspot with a radius equal to 10% of the stellar radius and a temperature contrast of \u2212600\u202fK, modeled using the appropriate PHOENIX spectrum for the spot temperature.</p> In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.cm import ScalarMappable\nfrom matplotlib.colors import TwoSlopeNorm\nfrom SOAP.utils import transgrad, compute_planet_doppler_shift, transit_durations\nfrom SOAP.visualizer import plot_absorption_map\nimport SOAP\nfrom SOAP import PHOENIX\nfrom SOAP.fast_starspot import doppler_shift\nfrom astropy.constants import M_earth, M_sun\nfrom IPython.display import HTML\n</pre> import numpy as np import matplotlib.pyplot as plt from matplotlib.cm import ScalarMappable from matplotlib.colors import TwoSlopeNorm from SOAP.utils import transgrad, compute_planet_doppler_shift, transit_durations from SOAP.visualizer import plot_absorption_map import SOAP from SOAP import PHOENIX from SOAP.fast_starspot import doppler_shift from astropy.constants import M_earth, M_sun from IPython.display import HTML In\u00a0[2]: Copied! <pre># Star-like star, rigid rotation\nradius=1                # Stellar radius [solar radii]\nmass=1                  # Stellar mass [solar masses]\nprot=24.47              # Stellar rotation period [days]\nincl=90                 # Stellar inclination [degrees] -&gt; 90 is equator-on, 0 is pole-on\nlogg= 4.4               # Stellar surface gravity [cgs]\nfeh= 0.00               # Stellar metallicity [dex]\nTeff=5777               # Stellar effective temperature [K]\nldcn=[[0.5,0.16]]       # Linear and quadratic limb-darkening coefficients\nstart_psi=0.0           # Starting phase of the star\n\n# Mock jupiter-like planet close to the star\nPp=3                    # Orbital period [days]\ne=0.0                   # Orbital eccentricity\nw=90.0                  # Argument of periastron [degrees]\nip=90                   # Orbital inclination [degrees]\nlbda=0                  # Sky-projected spin-orbit misalignement [degrees]\na=9                     # Semi-major axis [stellar radii]\nRp=0.15                 # Planetary radius [stellar radii]\nMp=317.8                # Planetary mass [Earth masses]\n\n# Observational parameters\n\u03bb =[5882, 5902]         # Wavelength range [Angstrom]\nRes=140000              # Instrumental resolution\n</pre> # Star-like star, rigid rotation radius=1                # Stellar radius [solar radii] mass=1                  # Stellar mass [solar masses] prot=24.47              # Stellar rotation period [days] incl=90                 # Stellar inclination [degrees] -&gt; 90 is equator-on, 0 is pole-on logg= 4.4               # Stellar surface gravity [cgs] feh= 0.00               # Stellar metallicity [dex] Teff=5777               # Stellar effective temperature [K] ldcn=[[0.5,0.16]]       # Linear and quadratic limb-darkening coefficients start_psi=0.0           # Starting phase of the star  # Mock jupiter-like planet close to the star Pp=3                    # Orbital period [days] e=0.0                   # Orbital eccentricity w=90.0                  # Argument of periastron [degrees] ip=90                   # Orbital inclination [degrees] lbda=0                  # Sky-projected spin-orbit misalignement [degrees] a=9                     # Semi-major axis [stellar radii] Rp=0.15                 # Planetary radius [stellar radii] Mp=317.8                # Planetary mass [Earth masses]  # Observational parameters \u03bb =[5882, 5902]         # Wavelength range [Angstrom] Res=140000              # Instrumental resolution <p>Where we use will import Phoenix spectra that match the stellar properties. These will be used to compute the RVs in the simulation</p> In\u00a0[3]: Copied! <pre>spQ = PHOENIX(wave_range=\u03bb, normalize=True, teff=Teff, logg=logg, Z=feh)\nspQ_active = PHOENIX(wave_range=\u03bb, normalize=True, teff=Teff, logg=logg, Z=feh, contrast=-600, spot=True)\n\ntplt={\"wave\":spQ.wave, \"flux\":spQ.flux} # Template spectrum matching the input local spectra to cumpute the RVs\n</pre> spQ = PHOENIX(wave_range=\u03bb, normalize=True, teff=Teff, logg=logg, Z=feh) spQ_active = PHOENIX(wave_range=\u03bb, normalize=True, teff=Teff, logg=logg, Z=feh, contrast=-600, spot=True)  tplt={\"wave\":spQ.wave, \"flux\":spQ.flux} # Template spectrum matching the input local spectra to cumpute the RVs In\u00a0[4]: Copied! <pre>sim = SOAP.Simulation(pixel=spQ, pixel_spot=spQ_active, wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=Res, grid=600, active_regions=[], ring=None)\n</pre> sim = SOAP.Simulation(pixel=spQ, pixel_spot=spQ_active, wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=Res, grid=600, active_regions=[], ring=None) In\u00a0[5]: Copied! <pre>sim.active_regions=[SOAP.ActiveRegion(check = True,\n                             lon = 0,\n                             lat = 0,\n                             size = 0.1 ,\n                             temp_diff = 600, # in K, this is the default value\n                             active_region_type = 0\n                            )]\n</pre> sim.active_regions=[SOAP.ActiveRegion(check = True,                              lon = 0,                              lat = 0,                              size = 0.1 ,                              temp_diff = 600, # in K, this is the default value                              active_region_type = 0                             )] In\u00a0[6]: Copied! <pre># Set the properties of the star and planet\nsim.star.set(prot=prot,incl=incl,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff)\nsim.planet.set(P=Pp,t0=start_psi,e=e,w=w,ip=ip,lbda=lbda,a=a,Rp=Rp,Mp=Mp)\n</pre> # Set the properties of the star and planet sim.star.set(prot=prot,incl=incl,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff) sim.planet.set(P=Pp,t0=start_psi,e=e,w=w,ip=ip,lbda=lbda,a=a,Rp=Rp,Mp=Mp) In\u00a0[7]: Copied! <pre># Provide the range of stellar phases to simulate\npsi = np.linspace(-0.1,0.1,50) / sim.star.prot\n</pre> # Provide the range of stellar phases to simulate psi = np.linspace(-0.1,0.1,50) / sim.star.prot In\u00a0[8]: Copied! <pre># Calculate the transit signal\nout=sim.calculate_signal(psi, renormalize_rv=True, template=tplt)\n</pre> # Calculate the transit signal out=sim.calculate_signal(psi, renormalize_rv=True, template=tplt) In\u00a0[9]: Copied! <pre># Convert from transmission to absorption [%]\nabsorption_spec=(1-sim.pixel_trans)*100\n</pre> # Convert from transmission to absorption [%] absorption_spec=(1-sim.pixel_trans)*100 In\u00a0[10]: Copied! <pre># Plot the absorption map in the stellar rest frame\nfig, ax = plot_absorption_map(sim,psi, absorption_spec,\u03bb)\nplt.show()\n</pre> # Plot the absorption map in the stellar rest frame fig, ax = plot_absorption_map(sim,psi, absorption_spec,\u03bb) plt.show()  In\u00a0[11]: Copied! <pre># Doppler shift of the map to the planetary rest frame\nabsorpt_prest=compute_planet_doppler_shift(sim,psi,absorption_spec)\n</pre> # Doppler shift of the map to the planetary rest frame absorpt_prest=compute_planet_doppler_shift(sim,psi,absorption_spec) In\u00a0[12]: Copied! <pre># Plot the absorption map in the planet rest frame\nfig, ax = plot_absorption_map(sim,psi,absorpt_prest,\u03bb)\nplt.show()\n</pre> # Plot the absorption map in the planet rest frame fig, ax = plot_absorption_map(sim,psi,absorpt_prest,\u03bb) plt.show() In\u00a0[13]: Copied! <pre># Create an animation of the transit with the absorption map\nani = sim.visualize_animation(\n    output=out,\n    plot_type=\"tr\",\n    lim=[5889.950-1.5, 5889.950+1.5],\n    ref_wave=5889.950,\n    plot_lims=[-1.1, 1.1]\n)\nHTML(ani.to_jshtml())\n</pre> # Create an animation of the transit with the absorption map ani = sim.visualize_animation(     output=out,     plot_type=\"tr\",     lim=[5889.950-1.5, 5889.950+1.5],     ref_wave=5889.950,     plot_lims=[-1.1, 1.1] ) HTML(ani.to_jshtml()) Out[13]: Once Loop Reflect"},{"location":"notebooks/Transit_time_spot_crossing/#spot-crossing-transit-absorption-time-series","title":"Spot-Crossing Transit &amp; Absorption Time-Series\u00b6","text":""},{"location":"notebooks/Transit_time_spot_crossing/#start-the-simulation","title":"Start the simulation\u00b6","text":""}]}