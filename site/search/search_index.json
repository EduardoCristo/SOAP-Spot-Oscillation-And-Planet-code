{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to SOAP's Documentation!","text":""},{"location":"#introduction","title":"Introduction","text":"<p>SOAPv4 (Spot Oscillation And Planet) is an open-source Python package designed to model the impact of stellar activity and planetary transits on high-resolution spectroscopic, radial velocity and photometric observations.  </p> <p>In the era of high-resolution spectroscopy, understanding how stellar features - such as spots and facula observables is essential for the accurate characterization of exoplanets and their atmospheres.</p> <p>Initially developed to simulate the radial velocity effects of stellar spots, SOAP has evolved over several versions to incorporate a wide range of physical phenomena and observing configurations. With SOAPv4, users can directly simulate both cross-correlation functions and full stellar spectra, modeling the impact of active regions, differential rotation, convective blueshift, and planet-induced line profile distortions.</p>"},{"location":"#some-of-the-use-cases-of-soap","title":"Some of the use cases of SOAP","text":"<p>SOAPv4 is especially suited for researchers who want to: - Compute time series of integrated stellar spectra - Assess stellar contamination in exoplanet transit spectra - Comput the photometric and radial velocity modulation of stellar activity - Model the signal of transiting planets for a wide range of stellar/planetary system parameters - Model transmission spectra (POLDs) and Doppler shadow in a simple way</p>"},{"location":"#development-of-soap-through-time","title":"Development of SOAP through Time","text":"<p>The SOAP code (Boisse et al. 2012) was originally developed to model the impact of stellar activity, particularly starspots, on radial velocity (RV) time series. In its first implementation, SOAP approximated the local stellar disk spectrum using cross-correlation functions (CCFs), represented as Gaussian profiles with user-defined parameters. For each stellar surface element, the corresponding CCF was Doppler-shifted according to local rotational velocities under the assumption of solid-body rotation, and flux-weighted according to a limb-darkening law.  </p> <p>Active regions (ARs) were introduced as circular areas, initially placed at the stellar disk center and then mapped to the appropriate latitude and longitude using spherical symmetry. The same Gaussian profile was applied to the ARs\u2019 CCFs, with their contribution scaled by a contrast parameter: values between 0 and 1 for dark spots, and values above 1 for bright faculae. Although simplistic, this framework introduced a first-order tool for quantifying the distortions introduced by stellar activity into RV measurements.  </p> <p>Building on this foundation, several successive versions expanded SOAP\u2019s scope:  </p> <ul> <li> <p>SOAP-T (Oshagh et al. 2013) incorporated transiting exoplanets. The code simulates the occultation of quiet-star (QS) pixels by subtracting their contribution during the transit, enabling simultaneous modeling of photometric light curves, Keplerian motion, and the Rossiter\u2013McLaughlin effect (Holt 1893; Rossiter 1924; McLaughlin 1924). This made SOAP-T a practical tool for probing spin\u2013orbit alignments in planetary systems.  </p> </li> <li> <p>SOAP 2.0 (Dumusque et al. 2014) improved the physical realism of the stellar activity modeling by grounding simulations in solar observations. High-resolution data from the Kitt Peak Fourier Transform Spectrograph (FTS), including spectra of quiet-sun (QS) regions (Wallace et al. 1998) and sunspot umbrae (Wallace et al. 2005), were incorporated. This allowed more realistic modeling of stellar line-profile deformations, particularly the effects of convective blueshift and its inhibition inside ARs. SOAP 2.0 also introduced facular limb brightening and spot/faculae contrasts determined via the Planck function across temperature differences. Despite these refinements, it still remained limited to synthetic CCFs rather than full spectra.  </p> </li> </ul> <p>Although not fully released to the public, intermediate versions significantly shaped later developments:  </p> <ul> <li>Oshagh et al. (2016) integrated upgrades from SOAP-T and SOAP 2.0 to investigate how stellar activity biases measurements of planetary spin\u2013orbit misalignments.  </li> <li>Akinsanmi et al. (2018) implemented extensions to simulate ringed planets and stellar rotational deformation, capturing their signatures in both photometric light curves and RVs during the Rossiter\u2013McLaughlin effect.  </li> <li>Serrano et al. (2020) and Cristo et al. (2024) added differential rotation (e.g., Balona &amp; Abedigamba 2016) and activity-related convective blueshift signals during planetary transits (Shporer &amp; Brown 2011). These additions pushed SOAP toward modeling stellar activity at a higher level of physical detail.  </li> </ul> <p>A parallel branch was developed in the form of SOAP-GPU (Zhao &amp; Dumusque 2023), a fork of SOAP 2.0 aimed at simulating stellar spectra instead of CCFs. SOAP-GPU introduced direct mapping of ARs, more sophisticated treatments of convective blueshift across the stellar disk based on empirical solar measurements (L\u00f6hner-B\u00f6ttcher et al. 2019), and GPU optimization for improved computational efficiency. Nevertheless, its reliance on GPU architectures reduced accessibility for many users, and it did not support planetary transits.  </p> <p>These various implementations ultimately converged in SOAPv4, the latest version of the code. By integrating the advances of all previous versions and extending beyond CCF-only output, SOAPv4 now produces time-resolved stellar spectra as well as CCFs. This marks a critical step in evolving SOAP from a specialized RV simulator into a comprehensive framework for modeling spectra, transit signals, stellar variability, and their interplay in exoplanetary science.  </p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>SOAPv4 is publicly available on GitHub: https://github.com/EduardoCristo/SOAP-Spot-Oscillation-And-Planet-code</p> <p>For detailed installation and usage instructions, see the Install Guide.</p>"},{"location":"#soap-history","title":"SOAP History","text":""},{"location":"install/","title":"Install","text":""},{"location":"install/#installation","title":"INSTALLATION","text":"<p>SOAP is written Python. To install run the following commands</p> <pre><code>git clone https://github.com/EduardoCristo/SOAP-Spot-Oscillation-And-Planet-code SOAP\ncd SOAP\n\npip install -e .\n</code></pre> <p>then you can use SOAP from Python with </p> <pre><code>&gt;&gt;&gt; import SOAP\n</code></pre>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#SOAP.ActiveRegion","title":"<code>ActiveRegion</code>","text":"<p>Represents an active region (spot or facula) on a stellar surface.</p> <p>Attributes:</p> Name Type Description <code>lon</code> <code>float or Quantity</code> <p>Longitude of the active region.</p> <code>lat</code> <code>float or Quantity</code> <p>Latitude of the active region.</p> <code>size</code> <code>float</code> <p>Size of the active region.</p> <code>active_region_type</code> <code>int</code> <p>0 for spot, 1 for plage.</p> <code>temp_diff</code> <code>float or Quantity</code> <p>Temperature difference [K].</p> <code>check</code> <code>bool</code> <p>Whether the region is active.</p> <p>Methods:</p> Name Description <code>random</code> <p>Create a random active region of the specified type.</p> <code>set</code> <p>Set attributes of the active region.</p> <code>get_size</code> <p>Get the size of the active region as a function of time.</p> Properties <p>type (str): Active region type, either \"spot\" or \"plage\". size_area_visible_hemisphere (float): Size of the active region in area of the visible hemisphere.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If active_region_type is not 0/1 or \"spot\"/\"plage\".</p>"},{"location":"reference/#SOAP.ActiveRegion.size_area_visible_hemisphere","title":"<code>size_area_visible_hemisphere</code>  <code>property</code> <code>writable</code>","text":"<p>Size of the active region, in area of the visible hemisphere</p>"},{"location":"reference/#SOAP.ActiveRegion.type","title":"<code>type</code>  <code>property</code> <code>writable</code>","text":"<p>Active region type, 'spot' or 'plage'</p>"},{"location":"reference/#SOAP.CCF","title":"<code>CCF</code>","text":""},{"location":"reference/#SOAP.CCF.n_v","title":"<code>n_v</code>  <code>property</code>","text":"<p>Total number of RV bins in the CCF after considering a stellar rotation velocity equal to vrot</p>"},{"location":"reference/#SOAP.CCF.vrot","title":"<code>vrot</code>  <code>property</code> <code>writable</code>","text":"<p>Rotation velocity of the star to which the CCF is associated</p>"},{"location":"reference/#SOAP.CCF.__init__","title":"<code>__init__(rv, intensity, normalize=True, convolved=False)</code>","text":"<p>Initialize the CCF object.</p>"},{"location":"reference/#SOAP.CCF.__init__--parameters","title":"Parameters","text":"<p>rv : array-like     Radial velocity array where the CCF is defined [km/s or astropy unit]. intensity : array-like     CCF intensity array. normalize : bool, optional     If True, normalize the CCF by its median. Default is True. convolved : bool, optional     If True, indicates that the CCF is already convolved with the instrumental profile. Default is False.</p>"},{"location":"reference/#SOAP.CCF.__init__--attributes","title":"Attributes","text":"<p>rv : array-like     Radial velocity array. intensity : array-like     Normalized or raw CCF intensity array.     Indicates if the CCF is convolved. n : int     Number of points in the CCF. step : float     Step size between consecutive RV points. width : float     Maximum absolute value of RV, representing the CCF width. _rv_units : astropy.units.Unit     Units of the RV array. _vrot : astropy.units.Quantity     Rotational velocity, initialized to zero.</p>"},{"location":"reference/#SOAP.Planet","title":"<code>Planet</code>","text":"<p>A planet (which may have rings)</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>float</code> <p>Orbital period [day]</p> required <code>a</code> <code>float</code> <p>Semi-major axis [stellar radius]</p> required <code>Rp</code> <code>float</code> <p>Planet radius [stellar radius]</p> required <code>Mp</code> <code>float</code> <p>Planet mass [Earth mass]</p> <code>None</code> <code>e</code> <code>float</code> <p>Eccentricity of the orbit. Default is 0</p> <code>0.0</code> <code>w</code> <code>float</code> <p>Argument of periastron [degree]. w=0 means periastron is on the yz plane, w=90 means it is in front of the observer. Default is 90</p> <code>90.0</code> <code>ip</code> <code>float</code> <p>Inclination of the orbital plane [degree]. Default is 90</p> <code>90.0</code> <code>lbda</code> <code>float</code> <p>Projected spin-orbit misalignment angle [degree]. Default is 0</p> <code>0.0</code> <code>t0</code> <code>float</code> <p>Time of periastron passage [day]. Default is 0</p> <code>0.0</code>"},{"location":"reference/#SOAP.Planet.add_ring","title":"<code>add_ring(fi=1.0, fe=1.0, ir=0.0, theta=0.0)</code>","text":"<p>Add a ring to this planet.</p>"},{"location":"reference/#SOAP.Planet.add_ring--parameters","title":"Parameters","text":"<p>fi : float, optional [default: 1.0]     Ring inner radius fe : float, optional [default: 1.0]     Ring outer radius ir : float, optional [default: 0.0]     Projected inclination of ring wrt to the skyplane [degrees].     90 for an edge-on ring, 0 for face on theta : float, optional [default: 0.0]     Projected ring tilt [degrees]. 90 means that the image of the ring in     perpendicular to the orbit in the plane of the sky.</p>"},{"location":"reference/#SOAP.Ring","title":"<code>Ring</code>","text":"<p>Ring of the planet</p>"},{"location":"reference/#SOAP.Ring--parameters","title":"Parameters","text":"<p>fi : float     Ring inner radius (must be &gt;= 1) fe : float     Ring outer radius (must be &gt;= 1 and &gt;= fi) ir : float     Projected inclination of ring wrt to the skyplane [degrees].     90 for an edge-on ring, 0 for face on theta : float     Projected ring tilt [degrees]. 90 means that the image of the ring in     perpendicular to the orbit in the plane of the sky.</p>"},{"location":"reference/#SOAP.Simulation","title":"<code>Simulation</code>","text":"<p>Simulation class for SOAP simulations. This class encapsulates the configuration and execution of SOAP simulations, which model the photometric and spectroscopic effects of stellar activity and planetary transits on observed signals.</p> <p>Attributes:</p> Name Type Description <code>star</code> <code>Star</code> <p>The star to be simulated. Defaults to the Sun if not provided.</p> <code>planet</code> <code>Planet</code> <p>The planet to be simulated. Defaults to a template planet if not provided.</p> <code>pixel</code> <code>CCF or Spectrum</code> <p>The CCF or spectrum for each pixel in the quiet star. Defaults to solar CCF.</p> <code>pixel_spot</code> <code>CCF or Spectrum</code> <p>The CCF or spectrum for the spot(s). Defaults to solar spot CCF.</p> <code>active_regions</code> <code>list of SOAP.ActiveRegion</code> <p>List of active regions to include in the simulation.</p> <code>ring</code> <code>Ring</code> <p>Optional ring system for the planet.</p> <code>nrho</code> <code>int</code> <p>Resolution for the active region's circumference.</p> <code>grid</code> <code>int</code> <p>Stellar grid resolution (grid x grid).</p> <code>inst_reso</code> <code>int</code> <p>Spectrograph resolution.</p> <code>wlll</code> <code>float</code> <p>Observation wavelength for temperature contrast by Planck's law, in Angstrom.</p> <code>resample_spectra</code> <code>int</code> <p>Resample the quiet star and spot spectra by this amount. No effect if using a CCF.</p> <code>interp_strategy</code> <code>str</code> <p>Strategy for interpolating pixel and pixel_spot to a common wavelength array.</p> <code>verbose</code> <code>bool</code> <p>If True, prints additional information during simulation.</p> <p>Methods:</p> Name Description <code>get_results</code> <p>Compute RV, FWHM, and BIS for a sequence of CCFs.</p> <code>set</code> <p>Set multiple attributes of the simulation at once.</p> <code>set_pixel</code> <p>Set the pixel, pixel_spot, and optionally pixel_plage for the simulation.</p> <code>plot</code> <p>Plot the simulation results.</p> <code>visualize</code> <p>Visualize the simulation output.</p> <code>visualize_animation</code> <p>Create an animated visualization of the simulation.</p> <code>plot_surface</code> <p>Plot the stellar surface.</p> <code>add_random_active_regions</code> <p>Add N random active regions (spots or plages) to the simulation.</p> <code>run_itot</code> <p>Calculate the CCF and total flux for the quiet star.</p> <code>calculate_signal</code> <p>Estimate photometric and spectroscopic effects for the simulation over a grid of stellar rotation phases.</p> <code>config_export</code> <p>Export the simulation configuration as a string for easy re-import.</p> Properties <p>_ccf_mode: Returns True if the simulation is in CCF mode. has_planet: Returns True if a planet is present in the simulation. has_active_regions: Returns True if active regions are present. has_ring: Returns True if the planet has a ring system.</p>"},{"location":"reference/#SOAP.Simulation.add_random_active_regions","title":"<code>add_random_active_regions(N=2, plage=False)</code>","text":"<p>Add a given number of active regions to the simulation, randomly distributed in the stellar surface</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of active regions to add</p> <code>2</code> <code>plage</code> <code>bool</code> <p>Whether to add plages or spots</p> <code>False</code>"},{"location":"reference/#SOAP.Simulation.calculate_signal","title":"<code>calculate_signal(psi=None, skip_itot=True, skip_rv=False, skip_fwhm=False, skip_bis=False, renormalize_rv=True, save_ccf=False, template=None, itot=None, **kwargs)</code>","text":"<p>Estimates the photometric and spectroscopic effects for a simulation over a grid of stellar rotation phases.</p> <p>Attributes:</p> Name Type Description <code>psi</code> <code>array_like</code> <p>Phases at which the signals will be calculated (in units of the stellar rotation period).</p> <code>skip_itot</code> <code>bool</code> <p>If True, only calculate the quiet star once and cache it.</p> <code>skip_rv</code> <code>bool</code> <p>If True, skip calculating the RV signal.</p> <code>skip_fwhm</code> <code>bool</code> <p>If True, skip calculating the FWHM signal.</p> <code>skip_bis</code> <code>bool</code> <p>If True, skip calculating the BIS signal.</p> <code>renormalize_rv</code> <code>bool</code> <p>If True, set RV when the spot is not visible to 0.</p> <code>save_ccf</code> <code>bool</code> <p>If True, save the output CCFs to a file.</p> <code>template</code> <code>dict</code> <p>Input spectrum to construct the CCF. Must contain: \"wave\" (nm) and \"flux\" arrays.</p> <code>itot</code> <code>tuple</code> <p>Precomputed quiet star pixel and flux to use instead of recalculating.</p> <code>**kwargs</code> <code>tuple</code> <p>Additional keyword arguments.</p> <p>Returns:</p> Name Type Description <code>output</code> <p>Instance containing psi, flux, rv, rv_bconv, rv_flux, ccf_fwhm, ccf_bis, ccf_depth, itot_quiet, and itot_flux as attributes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are invalid.</p>"},{"location":"reference/#SOAP.Simulation.config_export","title":"<code>config_export(simVar='sim', show_all=False)</code>","text":"<p>Return list (as string) of all variables that can easily be re-imported.</p>"},{"location":"reference/#SOAP.Simulation.run_itot","title":"<code>run_itot(skip_rv=False, cache=True)</code>","text":"<p>Calculate the CCF and the total flux for the quiet star</p>"},{"location":"reference/#SOAP.Simulation.set","title":"<code>set(**kwargs)</code>","text":"<p>Set (several) attributes of the simulation at once</p>"},{"location":"reference/#SOAP.Simulation.set_pixel","title":"<code>set_pixel(pixel, pixel_spot=None, pixel_plage=None)</code>","text":"<p>Set this simulation's pixel</p> <p>Parameters:</p> Name Type Description Default <code>pixel</code> <code>CCF or Spectrum</code> <p>The CCF or spectrum for each pixel in the quiet star</p> required <code>pixel_spot</code> <code>CCF or Spectrum</code> <p>The CCF for the spots</p> <code>None</code> <code>pixel_plage</code> <code>CCF or Spectrum</code> <p>The CCF for the plages</p> <code>None</code>"},{"location":"reference/#SOAP.Star","title":"<code>Star</code>","text":"<p>A star object holding stellar parameters.</p> <p>Parameters:</p> Name Type Description Default <code>prot</code> <code>float</code> <p>Stellar rotation period [days]. If differential rotation is on, this is the rotation period at the equator.</p> <code>25</code> <code>incl</code> <code>float</code> <p>Inclination of the rotational axis [degrees].</p> <code>90</code> <code>diffrotB</code> <code>float</code> <p>Coefficient for latitudinal differential rotation (sin^2 term).</p> <code>0</code> <code>diffrotC</code> <code>float</code> <p>Coefficient for latitudinal differential rotation (sin^4 term).</p> <code>0</code> <code>cb1</code> <code>float</code> <p>Absolute value of the convective blueshift (m/s).</p> <code>0</code> <code>u1</code> <code>float</code> <p>Linear coefficient of the quadratic limb-darkening law.</p> <code>0.29</code> <code>u2</code> <code>float</code> <p>Quadratic coefficient of the quadratic limb-darkening law.</p> <code>0.34</code> <code>radius</code> <code>float</code> <p>Stellar radius [R_sun].</p> <code>1</code> <code>mass</code> <code>float</code> <p>Stellar mass [M_sun].</p> <code>1</code> <code>teff</code> <code>float</code> <p>Effective temperature of the star [K].</p> <code>5778</code> <code>start_psi</code> <code>float</code> <p>Starting phase [in units of rotation period].</p> <code>0</code>"},{"location":"reference/#SOAP.Star.vrot","title":"<code>vrot</code>  <code>property</code>","text":"<p>Rotation velocity of the star at the equator</p>"},{"location":"reference/#SOAP.gaussianCCF","title":"<code>gaussianCCF</code>","text":"<p>               Bases: <code>CCF</code></p> <p>A Gaussian CCF defined by a depth [0-1] and a FWHM in km/s</p>"},{"location":"reference/#SOAP.gaussianCCF.__init__","title":"<code>__init__(depth=0.56, fwhm=2.5, RV=0.0, window=20, step=0.1, convolved=True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>depth</code> <code>float</code> <p>Amplitude of the CCF, between 0 and 1</p> <code>0.56</code> <code>fwhm</code> <code>float</code> <p>Full width at half maximum of the CCF [km/s]</p> <code>2.5</code> <code>RV</code> <code>float</code> <p>Radial velocity where the CCF is centered [km/s]</p> <code>0.0</code> <code>window</code> <code>float</code> <p>The CCF is defined between -window and +window [km/s]</p> <code>20</code> <code>step</code> <code>float</code> <p>Radial velocity step of the CCF [km/s]</p> <code>0.1</code> <code>convolved</code> <code>bool</code> <p>Whether the CCF is already convolved with the instrumental profile.</p> <code>True</code>"},{"location":"reference/#SOAP.solarCCF","title":"<code>solarCCF</code>","text":"<p>               Bases: <code>CCF</code></p> <p>Solar CCF obtained with the FTS spectrograph</p>"},{"location":"reference/#SOAP.solarCCF.__init__","title":"<code>__init__(vrot, active_region=False)</code>","text":""},{"location":"reference/#SOAP.solarCCF.__init__--arguments","title":"Arguments","text":"<p>vrot : float     Rotation velocity of the star (used to select a wider CCF window) active_region : bool, default False     Get the CCF for the active region instead of the quiet Sun</p>"},{"location":"notebooks/Sun_jupiter_phoenix/","title":"Sun\u2013Jupiter Transit Spectra Simulation","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.cm import ScalarMappable, get_cmap\nfrom matplotlib.colors import Normalize, LinearSegmentedColormap, TwoSlopeNorm\n\nimport SOAP\nfrom SOAP import PHOENIX\nfrom SOAP.fast_starspot import doppler_shift\n\nfrom ldtk import LDPSetCreator, BoxcarFilter\n</pre> import numpy as np import matplotlib.pyplot as plt from matplotlib.cm import ScalarMappable, get_cmap from matplotlib.colors import Normalize, LinearSegmentedColormap, TwoSlopeNorm  import SOAP from SOAP import PHOENIX from SOAP.fast_starspot import doppler_shift  from ldtk import LDPSetCreator, BoxcarFilter In\u00a0[2]: Copied! <pre>transgrad = LinearSegmentedColormap.from_list('Random gradient 9491', (\n    # Edit this gradient at https://eltos.github.io/gradient/#Random%20gradient%209491=008080-FFF2F2-440154\n    (0.000, (1.000, 0.000, 0.000)),  # Bright red (#FF0000) at the low end\n    (0.500, (1.000, 1.000, 1.000)),  # Bright gray (white) at the middle\n    (1.000, (0.000, 0.000, 0.545))))\n</pre> transgrad = LinearSegmentedColormap.from_list('Random gradient 9491', (     # Edit this gradient at https://eltos.github.io/gradient/#Random%20gradient%209491=008080-FFF2F2-440154     (0.000, (1.000, 0.000, 0.000)),  # Bright red (#FF0000) at the low end     (0.500, (1.000, 1.000, 1.000)),  # Bright gray (white) at the middle     (1.000, (0.000, 0.000, 0.545)))) In\u00a0[3]: Copied! <pre>#Star\nradius=1    # Solar Radii\nmass=1      # Solar mass\nprot=24.47\nincl=90         # Inclination of the stellar rotation axis relative to the sky-plane\ndiffrotB=0      # Differential roation coeff\ndiffrotC=0      # Differential roation coeff\nlogg= 4.4\nlogg_sig=0.001\nfeh= 0.00\nfeh_sig= 0.01\nTeff=5777\nTeff_sig=10\n\n#Planet\nstart_psi=0.0\nPp=3.13   # Orbital period in days\ne=0.0           # Orbital eccentricity\nw=90.0          # Argument of periastron\nip=90        # Orbital inclination\nlbda=0       # Sky-projected spin-orbit misalignement\na=9          # Semi-major axis\nRp= 0.15      # Planetary radius in stellar radii\nMp= 317.8       # Planetary mass in Earth masses\n</pre> #Star radius=1    # Solar Radii mass=1      # Solar mass prot=24.47 incl=90         # Inclination of the stellar rotation axis relative to the sky-plane diffrotB=0      # Differential roation coeff diffrotC=0      # Differential roation coeff logg= 4.4 logg_sig=0.001 feh= 0.00 feh_sig= 0.01 Teff=5777 Teff_sig=10  #Planet start_psi=0.0 Pp=3.13   # Orbital period in days e=0.0           # Orbital eccentricity w=90.0          # Argument of periastron ip=90        # Orbital inclination lbda=0       # Sky-projected spin-orbit misalignement a=9          # Semi-major axis Rp= 0.15      # Planetary radius in stellar radii Mp= 317.8       # Planetary mass in Earth masses In\u00a0[4]: Copied! <pre>\u03bb = (5882, 5902)\n</pre> \u03bb = (5882, 5902) In\u00a0[5]: Copied! <pre>filters = [BoxcarFilter('filter',\u03bb[0]/10, \u03bb[1]/10)] #expresso spectograph bandpass 380, 788nm\nsc = LDPSetCreator(teff=(Teff, 43),    # parametros da estrela\nlogg=(logg,logg_sig),\n z=(feh, feh_sig),\nfilters=filters)\nps = sc.create_profiles()      \t         # Create the limb darkening profiles\nldcn, qe = ps.coeffs_qd(do_mc=True) #coeficientes e os seus erros de perfil quadr\u00e1tico\n</pre> filters = [BoxcarFilter('filter',\u03bb[0]/10, \u03bb[1]/10)] #expresso spectograph bandpass 380, 788nm sc = LDPSetCreator(teff=(Teff, 43),    # parametros da estrela logg=(logg,logg_sig),  z=(feh, feh_sig), filters=filters) ps = sc.create_profiles()      \t         # Create the limb darkening profiles ldcn, qe = ps.coeffs_qd(do_mc=True) #coeficientes e os seus erros de perfil quadr\u00e1tico <p>Where we use will import Phoenix spectra that match the stellar properties. These will be used to compute the RVs in the simulation</p> In\u00a0[6]: Copied! <pre>spQt = PHOENIX(wave_range=\u03bb, normalize=True, teff=Teff, logg=logg, Z=0)\ntplt={\"wave\":spQt.wave, \"flux\":spQt.flux}\n</pre> spQt = PHOENIX(wave_range=\u03bb, normalize=True, teff=Teff, logg=logg, Z=0) tplt={\"wave\":spQt.wave, \"flux\":spQt.flux} In\u00a0[7]: Copied! <pre>spQ=spQt\n</pre> spQ=spQt In\u00a0[8]: Copied! <pre>sim = SOAP.Simulation( pixel=spQ, pixel_spot=None, wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=140000, grid=600, active_regions=[], ring=None)\n</pre> sim = SOAP.Simulation( pixel=spQ, pixel_spot=None, wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=140000, grid=600, active_regions=[], ring=None) In\u00a0[9]: Copied! <pre># Set the properties of the star and planet\nsim.star.set(prot=prot,incl=incl,diffrotB=diffrotB,diffrotC=diffrotC,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff)\nsim.planet.set(P=Pp,t0=start_psi,e=e,w=w,ip=ip,lbda=lbda,a=a,Rp=Rp,Mp=Mp)\n</pre> # Set the properties of the star and planet sim.star.set(prot=prot,incl=incl,diffrotB=diffrotB,diffrotC=diffrotC,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff) sim.planet.set(P=Pp,t0=start_psi,e=e,w=w,ip=ip,lbda=lbda,a=a,Rp=Rp,Mp=Mp) In\u00a0[10]: Copied! <pre># Check the properties\nprint(sim.star)\nprint(sim.planet)\n</pre> # Check the properties print(sim.star) print(sim.planet)  <pre>SOAP.Star(prot=24.47 d; incl=90.0 deg; radius=1.0 solRad; teff=5777 K)\nSOAP.Planet(P=3.13 d; t0=0.0 d; e=0.0; w=90.0 deg; ip=90.0 deg; lbda=0.0 deg; a=9.0 solRad, Rp=0.15 solRad)\n</pre> In\u00a0[11]: Copied! <pre># Provide the phases normalized by the stellar rotation\npsi = np.linspace(-0.1,0.1,50) / sim.star.prot\n</pre> # Provide the phases normalized by the stellar rotation psi = np.linspace(-0.1,0.1,50) / sim.star.prot In\u00a0[12]: Copied! <pre># Calculate the transit signal\nout=sim.calculate_signal(psi, renormalize_rv=True, template=tplt)\n</pre> # Calculate the transit signal out=sim.calculate_signal(psi, renormalize_rv=True, template=tplt) In\u00a0[13]: Copied! <pre># Convert from transmission to absorption in percentage\nabsorption_spec=(1-sim.pixel_trans)*100\n</pre> # Convert from transmission to absorption in percentage absorption_spec=(1-sim.pixel_trans)*100 In\u00a0[14]: Copied! <pre># Compute transit duration and ingress/egress duration\ntr_dur=1./np.pi * np.arcsin(1./a *np.sqrt((1+Rp )**2.-a**2. *np.cos(np.radians(ip))**2.))\ntr_ingress_egress=1./np.pi * np.arcsin(1./a *np.sqrt((1.-Rp)**2.-a**2. *np.cos(np.radians(ip))**2.))\n</pre> # Compute transit duration and ingress/egress duration tr_dur=1./np.pi * np.arcsin(1./a *np.sqrt((1+Rp )**2.-a**2. *np.cos(np.radians(ip))**2.)) tr_ingress_egress=1./np.pi * np.arcsin(1./a *np.sqrt((1.-Rp)**2.-a**2. *np.cos(np.radians(ip))**2.)) In\u00a0[15]: Copied! <pre># Convert phases to planetary orbital phases\npsi_planet=(psi*sim.star.prot/sim.planet.P).value\n</pre> # Convert phases to planetary orbital phases psi_planet=(psi*sim.star.prot/sim.planet.P).value In\u00a0[16]: Copied! <pre>X,Y=np.meshgrid(sim.pixel.wave,psi_planet)\nfig, ax = plt.subplots(figsize=(14,7))\n\nnorm = TwoSlopeNorm(vmin=np.min(absorption_spec), vcenter=0, vmax=np.max(absorption_spec))  # Center at zero\nim=ax.pcolor(X,Y,absorption_spec, cmap=transgrad, norm=norm)\n\nax.plot(\u03bb, [-tr_dur/2, -tr_dur/2], '-k')\nax.plot(\u03bb, [tr_dur/2, tr_dur/2], '-k')\nax.plot(\u03bb, [-tr_ingress_egress/2, -tr_ingress_egress/2], '--k')\nax.plot(\u03bb, [tr_ingress_egress/2, tr_ingress_egress/2], '--k')\nax.set_xlim(\u03bb[0], \u03bb[1])\nax.set_xlabel(\"Wavelength \"+r\"$\\AA$\")\nax.set_ylabel(\"Orbital Phase\")\n\n#colorbar\nsm = ScalarMappable(cmap=im.get_cmap())\nsm.set_clim(np.min(absorption_spec), np.max(absorption_spec))\nsm.set_array([])  # Set an empty array (required)\n\n# Change colorbar size and position\nfig = plt.gcf()\n\n# Get the position of the main image axes\nimage_position = im.axes.get_position()\n\n# Create the colorbar axes with a slightly smaller width for spacing\ncolorbard_width = image_position.width * 0.03  # Adjust width as needed\nax = fig.add_axes([image_position.x1+0.011, image_position.y0, colorbard_width, image_position.height])\nfig.colorbar(sm, cax=ax, label=\"Absorption (%)\")  # Add a label\n</pre> X,Y=np.meshgrid(sim.pixel.wave,psi_planet) fig, ax = plt.subplots(figsize=(14,7))  norm = TwoSlopeNorm(vmin=np.min(absorption_spec), vcenter=0, vmax=np.max(absorption_spec))  # Center at zero im=ax.pcolor(X,Y,absorption_spec, cmap=transgrad, norm=norm)  ax.plot(\u03bb, [-tr_dur/2, -tr_dur/2], '-k') ax.plot(\u03bb, [tr_dur/2, tr_dur/2], '-k') ax.plot(\u03bb, [-tr_ingress_egress/2, -tr_ingress_egress/2], '--k') ax.plot(\u03bb, [tr_ingress_egress/2, tr_ingress_egress/2], '--k') ax.set_xlim(\u03bb[0], \u03bb[1]) ax.set_xlabel(\"Wavelength \"+r\"$\\AA$\") ax.set_ylabel(\"Orbital Phase\")  #colorbar sm = ScalarMappable(cmap=im.get_cmap()) sm.set_clim(np.min(absorption_spec), np.max(absorption_spec)) sm.set_array([])  # Set an empty array (required)  # Change colorbar size and position fig = plt.gcf()  # Get the position of the main image axes image_position = im.axes.get_position()  # Create the colorbar axes with a slightly smaller width for spacing colorbard_width = image_position.width * 0.03  # Adjust width as needed ax = fig.add_axes([image_position.x1+0.011, image_position.y0, colorbard_width, image_position.height]) fig.colorbar(sm, cax=ax, label=\"Absorption (%)\")  # Add a label  Out[16]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x7e21a5a8e660&gt;</pre> In\u00a0[17]: Copied! <pre>from astropy.constants import M_earth, M_sun\n</pre> from astropy.constants import M_earth, M_sun In\u00a0[18]: Copied! <pre>Kp=(sim.planet.K)*(M_sun*sim.star.mass)/(sim.planet.Mp*(M_earth))\npshift=(Kp*np.sin(2*np.pi*psi_planet)).value\n</pre> Kp=(sim.planet.K)*(M_sun*sim.star.mass)/(sim.planet.Mp*(M_earth)) pshift=(Kp*np.sin(2*np.pi*psi_planet)).value  In\u00a0[19]: Copied! <pre>absorpt_prest=np.array([doppler_shift(sim.pixel.wave,absorption_spec[x],-1000*pshift[x]) for x in range(len(pshift))])\n</pre> absorpt_prest=np.array([doppler_shift(sim.pixel.wave,absorption_spec[x],-1000*pshift[x]) for x in range(len(pshift))]) In\u00a0[20]: Copied! <pre>X,Y=np.meshgrid(sim.pixel.wave,psi_planet)\nfig, ax = plt.subplots(figsize=(13,7))\n\nnorm = TwoSlopeNorm(vmin=np.min(absorpt_prest), vcenter=0, vmax=np.max(absorpt_prest))  # Center at zero\nim=ax.pcolor(X,Y,absorpt_prest, cmap=transgrad, norm=norm)\nax.set_xlabel(\"Wavelength \"+r\"$\\AA$\")\nax.set_ylabel(\"Orbital Phase\")\n\n\nplt.plot(\u03bb, [-tr_dur/2, -tr_dur/2], '-k')\nplt.plot(\u03bb, [tr_dur/2, tr_dur/2], '-k')\nplt.plot(\u03bb, [-tr_ingress_egress/2, -tr_ingress_egress/2], '--k')\nplt.plot(\u03bb, [tr_ingress_egress/2, tr_ingress_egress/2], '--k')\n\nsm = ScalarMappable(cmap=im.get_cmap())\nsm.set_clim(np.min(absorption_spec), np.max(absorption_spec))\n\nsm.set_array([])  # Set an empty array (required)\nfig = plt.gcf()\n\n# Get the position of the main image axes\nimage_position = im.axes.get_position()\n\n# Create the colorbar axes with a slightly smaller width for spacing\ncolorbard_width = image_position.width * 0.03  # Adjust width as needed\nax = fig.add_axes([image_position.x1+0.011, image_position.y0, colorbard_width, image_position.height])\nfig.colorbar(sm, cax=ax, label=\"Absorption (%)\")  # Add a label\n</pre> X,Y=np.meshgrid(sim.pixel.wave,psi_planet) fig, ax = plt.subplots(figsize=(13,7))  norm = TwoSlopeNorm(vmin=np.min(absorpt_prest), vcenter=0, vmax=np.max(absorpt_prest))  # Center at zero im=ax.pcolor(X,Y,absorpt_prest, cmap=transgrad, norm=norm) ax.set_xlabel(\"Wavelength \"+r\"$\\AA$\") ax.set_ylabel(\"Orbital Phase\")   plt.plot(\u03bb, [-tr_dur/2, -tr_dur/2], '-k') plt.plot(\u03bb, [tr_dur/2, tr_dur/2], '-k') plt.plot(\u03bb, [-tr_ingress_egress/2, -tr_ingress_egress/2], '--k') plt.plot(\u03bb, [tr_ingress_egress/2, tr_ingress_egress/2], '--k')  sm = ScalarMappable(cmap=im.get_cmap()) sm.set_clim(np.min(absorption_spec), np.max(absorption_spec))  sm.set_array([])  # Set an empty array (required) fig = plt.gcf()  # Get the position of the main image axes image_position = im.axes.get_position()  # Create the colorbar axes with a slightly smaller width for spacing colorbard_width = image_position.width * 0.03  # Adjust width as needed ax = fig.add_axes([image_position.x1+0.011, image_position.y0, colorbard_width, image_position.height]) fig.colorbar(sm, cax=ax, label=\"Absorption (%)\")  # Add a label Out[20]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x7e21b7b01590&gt;</pre> In\u00a0[21]: Copied! <pre>mask_T2_T3 = np.logical_and(psi_planet&gt; -tr_ingress_egress / 2, psi_planet&lt; tr_ingress_egress / 2)\nmask_T1_T4 = np.logical_and(psi_planet&gt; -tr_dur / 2, psi_planet&lt; tr_dur / 2)\n</pre> mask_T2_T3 = np.logical_and(psi_planet&gt; -tr_ingress_egress / 2, psi_planet&lt; tr_ingress_egress / 2) mask_T1_T4 = np.logical_and(psi_planet&gt; -tr_dur / 2, psi_planet&lt; tr_dur / 2) In\u00a0[22]: Copied! <pre>mean_T2_T3=np.mean(absorpt_prest[mask_T2_T3], axis=0)\nmean_T1_T4=np.mean(absorpt_prest[mask_T1_T4], axis=0)\n</pre> mean_T2_T3=np.mean(absorpt_prest[mask_T2_T3], axis=0) mean_T1_T4=np.mean(absorpt_prest[mask_T1_T4], axis=0) In\u00a0[23]: Copied! <pre>plt.plot(sim.pixel.wave,mean_T2_T3,\"k\", label=\"T2-T3\")\nplt.plot(sim.pixel.wave,mean_T1_T4,\"b\", label=\"T1-T4\")\nplt.legend()\nplt.xlim(5894,5898)\nplt.xlabel(\"Wavelength (\"+r\"$\\AA$)\")\nplt.ylabel(\"Absorption (%)\")\n</pre> plt.plot(sim.pixel.wave,mean_T2_T3,\"k\", label=\"T2-T3\") plt.plot(sim.pixel.wave,mean_T1_T4,\"b\", label=\"T1-T4\") plt.legend() plt.xlim(5894,5898) plt.xlabel(\"Wavelength (\"+r\"$\\AA$)\") plt.ylabel(\"Absorption (%)\") Out[23]: <pre>Text(0, 0.5, 'Absorption (%)')</pre> In\u00a0[24]: Copied! <pre>sim.visualize(output=out,plot_type=\"rv\")\n</pre> sim.visualize(output=out,plot_type=\"rv\") In\u00a0[30]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>sim.visualize_animation(output=out,plot_type=\"tr\", plot_lims=[-0.75,0.75], repeat=True, ref_wave=5890)\n</pre> sim.visualize_animation(output=out,plot_type=\"tr\", plot_lims=[-0.75,0.75], repeat=True, ref_wave=5890) Out[\u00a0]: <pre>&lt;matplotlib.animation.FuncAnimation at 0x7e21b8175d90&gt;</pre>"},{"location":"notebooks/Sun_jupiter_phoenix/#sunjupiter-transit-spectra-simulation","title":"Sun\u2013Jupiter Transit Spectra Simulation\u00b6","text":"<p>This notebook simulates the transmission spectrum and Doppler signals of a Sun\u2013Jupiter transit using the SOAP framework and PHOENIX stellar atmosphere models.</p>"},{"location":"notebooks/Sun_jupiter_phoenix/#start-the-simulation","title":"Start the simulation\u00b6","text":""},{"location":"notebooks/compare_batman/","title":"Basic Example","text":"In\u00a0[1]: Copied! <pre>import batman\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> import batman import numpy as np import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>params = batman.TransitParams()\nparams.t0 = 0.                       #time of inferior conjunction\nparams.per = 1.                      #orbital period\nparams.rp = 0.15                      #planet radius (in units of stellar radii)\nparams.a = 15.                       #semi-major axis (in units of stellar radii)\nparams.inc = 90.                     #orbital inclination (in degrees)\nparams.ecc = 0.                      #eccentricity\nparams.w = 90.                       #longitude of periastron (in degrees)\nparams.u = [0.9, 0.1]                #limb darkening coefficients [u1, u2]\nparams.limb_dark = \"quadratic\"       #limb darkening model\n</pre> params = batman.TransitParams() params.t0 = 0.                       #time of inferior conjunction params.per = 1.                      #orbital period params.rp = 0.15                      #planet radius (in units of stellar radii) params.a = 15.                       #semi-major axis (in units of stellar radii) params.inc = 90.                     #orbital inclination (in degrees) params.ecc = 0.                      #eccentricity params.w = 90.                       #longitude of periastron (in degrees) params.u = [0.9, 0.1]                #limb darkening coefficients [u1, u2] params.limb_dark = \"quadratic\"       #limb darkening model In\u00a0[3]: Copied! <pre>t = np.linspace(-0.02, 0.02, 1000)\n</pre> t = np.linspace(-0.02, 0.02, 1000) In\u00a0[4]: Copied! <pre>m = batman.TransitModel(params, t)    #initializes model\nflux = m.light_curve(params)          #calculates light curve\n</pre> m = batman.TransitModel(params, t)    #initializes model flux = m.light_curve(params)          #calculates light curve In\u00a0[5]: Copied! <pre>plt.plot(t, flux)\nplt.xlabel(\"Time from central transit\")\nplt.ylabel(\"Relative flux\")\nplt.show()\n</pre> plt.plot(t, flux) plt.xlabel(\"Time from central transit\") plt.ylabel(\"Relative flux\") plt.show()   In\u00a0[6]: Copied! <pre>import SOAP\n</pre> import SOAP In\u00a0[7]: Copied! <pre>sim = SOAP.Simulation()\nsim.grid=801\n</pre> sim = SOAP.Simulation() sim.grid=801 In\u00a0[8]: Copied! <pre>print(sim.planet)\nsim.planet.Mp=300\n</pre> print(sim.planet) sim.planet.Mp=300 <pre>SOAP.Planet(P=4.0 d; t0=0.0 d; e=0.0; w=90.0 deg; ip=90.0 deg; lbda=0.0 deg; a=8.76 solRad, Rp=0.1 solRad)\n</pre> In\u00a0[9]: Copied! <pre>print(sim.star)\n</pre> print(sim.star) <pre>SOAP.Star(prot=25.05 d; incl=90.0 deg; radius=1.0 solRad; teff=5778 K)\n</pre> In\u00a0[10]: Copied! <pre>sim.planet.Rp=params.rp\nsim.planet.a=params.a\nsim.planet.P=params.per\nsim.star.u1=params.u[0]\nsim.star.u2=params.u[1]\nsim.active_regions=[]\n</pre> sim.planet.Rp=params.rp sim.planet.a=params.a sim.planet.P=params.per sim.star.u1=params.u[0] sim.star.u2=params.u[1] sim.active_regions=[] In\u00a0[11]: Copied! <pre>print(sim.planet)\n</pre> print(sim.planet) <pre>SOAP.Planet(P=1.0 d; t0=0.0 d; e=0.0; w=90.0 deg; ip=90.0 deg; lbda=0.0 deg; a=15.0 solRad, Rp=0.15 solRad)\n</pre> In\u00a0[12]: Copied! <pre>sim.star.prot=5\n</pre> sim.star.prot=5 In\u00a0[13]: Copied! <pre>out=sim.calculate_signal(psi=t*sim.planet.P/sim.star.prot)\n</pre> out=sim.calculate_signal(psi=t*sim.planet.P/sim.star.prot)  In\u00a0[14]: Copied! <pre>plt.plot(out.psi, out.flux)\nplt.plot(out.psi, flux)\n</pre> plt.plot(out.psi, out.flux) plt.plot(out.psi, flux) Out[14]: <pre>[&lt;matplotlib.lines.Line2D at 0x76f00c59e490&gt;]</pre> In\u00a0[15]: Copied! <pre>plt.plot(out.psi,(out.flux-flux)*1e6)\n\nnp.mean((out.flux-flux)*1e6)\n</pre> plt.plot(out.psi,(out.flux-flux)*1e6)  np.mean((out.flux-flux)*1e6) Out[15]:  $-0.67780581 \\; \\mathrm{}$  In\u00a0[16]: Copied! <pre>plt.plot(out.psi, out.rv)\nprint(out.rv[0])\n</pre> plt.plot(out.psi, out.rv) print(out.rv[0]) <pre>0.024029537928860173 km / s\n</pre>"}]}