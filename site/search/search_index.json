{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to SOAP's Documentation!","text":""},{"location":"#introduction","title":"Introduction","text":"<p>SOAPv4 (\"Spot Oscillation And Planet\") is a open-source Python package designed to model the impact of stellar activity and planetary transits on high-resolution spectroscopic and photometric observatiosn. In the era of high-resolution spectroscopy, understanding how stellar features like spots, faculae, and granulation influence observables is crucial for the accurate characterization of both exoplanets and their atmospheres.</p> <p>Initially conceived to simulate the radial velocity (RV) effects of stellar spots, SOAP has expanded over several versions to incorporate a range of physical phenomena and observational configurations. With SOAPv4, the tool now enables direct simulation of both cross-correlation functions (CCFs) and full stellar spectra, capturing the complexities of active regions, differential rotation, convective blueshift, and planet-induced line profile distortions.</p> <p>When to Use SOAPv4</p> <p>SOAPv4 is essential for researchers aiming to:</p> <pre><code>Assess stellar contamination in exoplanet transit spectra and RV data\n\nInterpret or validate observed absorption features in the presence of stellar variability\n\nModel the signal of transiting planets for a range of stellar/planetary system parameters\n\nSimulate high-resolution spectroscopic time series, including chromatic and Doppler-shadow diagnostics\n</code></pre> <p>Whether the goal is to study the impact of active regions on atmospheric characterization, quantify the granulation noise for planet detection, or benchmark models against solar data, SOAPv4 provides a robust and flexible numerical framework to address these challenges.</p> <p>Getting Started</p> <p>SOAPv4 is publicly available on GitHub: https://github.com/EduardoCristo/SOAP-Spot-Oscillation-And-Planet-code</p> <p>For detailed installation and usage instructions, proceed to the Install</p>"},{"location":"#welcome-to-soaps-documentation_1","title":"Welcome to SOAP's Documentation!","text":"<p>SOAP (Spot Oscillation and Planet) estimates the effects of active regions, spots, or plages on radial-velocity (RV) and photometric observations.</p> <p>The code calculates the RV, bisector span, and full width at half maximum (FWHM), defined with the cross-correlation technique and optimized to reproduce HARPS (HARPS-N) observations. The photometric variations induced by active regions (flux at 5293 Angstrom) can also be calculated.</p>"},{"location":"#soap-history","title":"SOAP History","text":""},{"location":"#contents","title":"Contents","text":"<ul> <li>Install</li> <li>Quickstart</li> </ul>"},{"location":"install/","title":"Install","text":""},{"location":"install/#installation","title":"INSTALLATION","text":"<p>SOAP is written Python. To install run the following commands</p> <pre><code>git clone https://github.com/EduardoCristo/SOAP-Spot-Oscillation-And-Planet-code SOAP\ncd SOAP\n\npip install -e .\n</code></pre> <p>then you can use SOAP from Python with </p> <pre><code>&gt;&gt;&gt; import SOAP\n</code></pre>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#SOAP.ActiveRegion","title":"<code>ActiveRegion</code>","text":"<p>Represents an active region (spot or facula) on a stellar surface.</p> <p>Attributes:</p> Name Type Description <code>lon</code> <code>float or Quantity</code> <p>Longitude of the active region.</p> <code>lat</code> <code>float or Quantity</code> <p>Latitude of the active region.</p> <code>size</code> <code>float</code> <p>Size of the active region.</p> <code>active_region_type</code> <code>int</code> <p>0 for spot, 1 for plage.</p> <code>temp_diff</code> <code>float or Quantity</code> <p>Temperature difference [K].</p> <code>check</code> <code>bool</code> <p>Whether the region is active.</p> <p>Methods:</p> Name Description <code>random</code> <p>Create a random active region of the specified type.</p> <code>set</code> <p>Set attributes of the active region.</p> <code>get_size</code> <p>Get the size of the active region as a function of time.</p> Properties <p>type (str): Active region type, either \"spot\" or \"plage\". size_area_visible_hemisphere (float): Size of the active region in area of the visible hemisphere.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If active_region_type is not 0/1 or \"spot\"/\"plage\".</p>"},{"location":"reference/#SOAP.ActiveRegion.size_area_visible_hemisphere","title":"<code>size_area_visible_hemisphere</code>  <code>property</code> <code>writable</code>","text":"<p>Size of the active region, in area of the visible hemisphere</p>"},{"location":"reference/#SOAP.ActiveRegion.type","title":"<code>type</code>  <code>property</code> <code>writable</code>","text":"<p>Active region type, 'spot' or 'plage'</p>"},{"location":"reference/#SOAP.CCF","title":"<code>CCF</code>","text":""},{"location":"reference/#SOAP.CCF.n_v","title":"<code>n_v</code>  <code>property</code>","text":"<p>Total number of RV bins in the CCF after considering a stellar rotation velocity equal to self.vrot.</p>"},{"location":"reference/#SOAP.CCF.vrot","title":"<code>vrot</code>  <code>property</code> <code>writable</code>","text":"<p>Rotation velocity of the star to which the CCF is associated</p>"},{"location":"reference/#SOAP.CCF.__init__","title":"<code>__init__(rv, intensity, normalize=True, convolved=False)</code>","text":""},{"location":"reference/#SOAP.CCF.__init__--arguments","title":"Arguments","text":"<p>rv : array     RV array where the CCF is defined [km/s or astropy unit] intensity : array     CCF array normalize : bool     Whether to normalize the CCF by its median convolved : bool     Whether the CCF is already convolved with the instrumental profile</p>"},{"location":"reference/#SOAP.Simulation","title":"<code>Simulation</code>","text":"<p>Simulation class for SOAP simulations. This class encapsulates the configuration and execution of SOAP simulations, which model the photometric and spectroscopic effects of stellar activity and planetary transits on observed signals.</p> <p>Attributes:</p> Name Type Description <code>star</code> <code>Star</code> <p>The star to be simulated. Defaults to the Sun if not provided.</p> <code>planet</code> <code>Planet</code> <p>The planet to be simulated. Defaults to a template planet if not provided.</p> <code>pixel</code> <code>CCF or Spectrum</code> <p>The CCF or spectrum for each pixel in the quiet star. Defaults to solar CCF.</p> <code>pixel_spot</code> <code>CCF or Spectrum</code> <p>The CCF or spectrum for the spot(s). Defaults to solar spot CCF.</p> <code>active_regions</code> <code>list of SOAP.ActiveRegion</code> <p>List of active regions to include in the simulation.</p> <code>ring</code> <code>Ring</code> <p>Optional ring system for the planet.</p> <code>nrho</code> <code>int</code> <p>Resolution for the active region's circumference.</p> <code>grid</code> <code>int</code> <p>Stellar grid resolution (grid x grid).</p> <code>inst_reso</code> <code>int</code> <p>Spectrograph resolution.</p> <code>wlll</code> <code>float</code> <p>Observation wavelength for temperature contrast by Planck's law, in Angstrom.</p> <code>resample_spectra</code> <code>int</code> <p>Resample the quiet star and spot spectra by this amount. No effect if using a CCF.</p> <code>interp_strategy</code> <code>str</code> <p>Strategy for interpolating pixel and pixel_spot to a common wavelength array.</p> <code>verbose</code> <code>bool</code> <p>If True, prints additional information during simulation.</p> <p>Methods:</p> Name Description <code>get_results</code> <p>Compute RV, FWHM, and BIS for a sequence of CCFs.</p> <code>set</code> <p>Set multiple attributes of the simulation at once.</p> <code>set_pixel</code> <p>Set the pixel, pixel_spot, and optionally pixel_plage for the simulation.</p> <code>plot</code> <p>Plot the simulation results.</p> <code>visualize</code> <p>Visualize the simulation output.</p> <code>visualize_animation</code> <p>Create an animated visualization of the simulation.</p> <code>plot_surface</code> <p>Plot the stellar surface.</p> <code>add_random_active_regions</code> <p>Add N random active regions (spots or plages) to the simulation.</p> <code>run_itot</code> <p>Calculate the CCF and total flux for the quiet star.</p> <code>calculate_signal</code> <p>Estimate photometric and spectroscopic effects for the simulation over a grid of stellar rotation phases.</p> <code>config_export</code> <p>Export the simulation configuration as a string for easy re-import.</p> Properties <p>_ccf_mode: Returns True if the simulation is in CCF mode. has_planet: Returns True if a planet is present in the simulation. has_active_regions: Returns True if active regions are present. has_ring: Returns True if the planet has a ring system.</p>"},{"location":"reference/#SOAP.Simulation.add_random_active_regions","title":"<code>add_random_active_regions(N=2, plage=False)</code>","text":"<p>Add a given number of active regions to the simulation, randomly distributed in the stellar surface</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of active regions to add</p> <code>2</code> <code>plage</code> <code>bool</code> <p>Whether to add plages or spots</p> <code>False</code>"},{"location":"reference/#SOAP.Simulation.calculate_signal","title":"<code>calculate_signal(psi=None, skip_itot=True, skip_rv=False, skip_fwhm=False, skip_bis=False, renormalize_rv=True, save_ccf=False, template=None, itot=None, **kwargs)</code>","text":"<p>Estimates the photometric and spectroscopic effects for a simulation over a grid of stellar rotation phases.</p> <p>Attributes:</p> Name Type Description <code>psi</code> <code>array_like</code> <p>Phases at which the signals will be calculated (in units of the stellar rotation period).</p> <code>skip_itot</code> <code>bool</code> <p>If True, only calculate the quiet star once and cache it.</p> <code>skip_rv</code> <code>bool</code> <p>If True, skip calculating the RV signal.</p> <code>skip_fwhm</code> <code>bool</code> <p>If True, skip calculating the FWHM signal.</p> <code>skip_bis</code> <code>bool</code> <p>If True, skip calculating the BIS signal.</p> <code>renormalize_rv</code> <code>bool</code> <p>If True, set RV when the spot is not visible to 0.</p> <code>save_ccf</code> <code>bool</code> <p>If True, save the output CCFs to a file.</p> <code>template</code> <code>dict</code> <p>Input spectrum to construct the CCF. Must contain: \"wave\" (nm) and \"flux\" arrays.</p> <code>itot</code> <code>tuple</code> <p>Precomputed quiet star pixel and flux to use instead of recalculating.</p> <code>**kwargs</code> <code>tuple</code> <p>Additional keyword arguments.</p> <p>Returns:</p> Name Type Description <code>output</code> <p>Instance containing psi, flux, rv, rv_bconv, rv_flux, ccf_fwhm, ccf_bis, ccf_depth, itot_quiet, and itot_flux as attributes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are invalid.</p>"},{"location":"reference/#SOAP.Simulation.config_export","title":"<code>config_export(simVar='sim', show_all=False)</code>","text":"<p>Return list (as string) of all variables that can easily be re-imported.</p>"},{"location":"reference/#SOAP.Simulation.run_itot","title":"<code>run_itot(skip_rv=False, cache=True)</code>","text":"<p>Calculate the CCF and the total flux for the quiet star</p>"},{"location":"reference/#SOAP.Simulation.set","title":"<code>set(**kwargs)</code>","text":"<p>Set (several) attributes of the simulation at once</p>"},{"location":"reference/#SOAP.Simulation.set_pixel","title":"<code>set_pixel(pixel, pixel_spot=None, pixel_plage=None)</code>","text":"<p>Set this simulation's pixel</p> <p>Parameters:</p> Name Type Description Default <code>pixel</code> <code>CCF or Spectrum</code> <p>The CCF or spectrum for each pixel in the quiet star</p> required <code>pixel_spot</code> <code>CCF or Spectrum</code> <p>The CCF for the spots</p> <code>None</code> <code>pixel_plage</code> <code>CCF or Spectrum</code> <p>The CCF for the plages</p> <code>None</code> <p>Examples:</p> <p>sim.set_pixel( SOAP.gaussianCCF() ) sim.set_pixel( SOAP.solarCCF(sim.star.vrot) ) # this is the default</p>"},{"location":"reference/#SOAP.Star","title":"<code>Star</code>","text":"<p>This object holds information about the star</p>"},{"location":"reference/#SOAP.Star--parameters","title":"Parameters","text":"<p>prot : float     Stellar rotation period [days]. If differential rotation is on, this is     the rotation period at the equator. incl : float     Inclination of the rotational axis [degrees] diffrotB, diffrotC : float     Coefficients for the latitudinal differential rotation         w(lat) = w_eq - diffrotB * sin^2(lat) - diffrotC * sin^4(lat)     (NOTE the minus signs!) cb1: float     Absolute value of the convective blueshift (m/s)     V_CB=cb1rcos(theta) u1, u2 : float     Linear and quadratic coefficients of the quadratic limb-darkening law radius : float     Stellar radius [Rsun] mass : float     Stellar mass [Msun] teff : float     Effective temperature of the star [K] start_psi : float     Starting phase [in units of rotation period]</p>"},{"location":"reference/#SOAP.Star.vrot","title":"<code>vrot</code>  <code>property</code>","text":"<p>Rotation velocity of the star at the equator</p>"},{"location":"notebooks/Sun_jupiter_phoenix/","title":"Transmission spectrum of a transit event","text":"In\u00a0[1]: Copied! <pre>import SOAP\nfrom SOAP import PHOENIX,Spec_mu\nfrom SOAP.fast_starspot import doppler_shift\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.cm import ScalarMappable, get_cmap\nfrom matplotlib.colors import Normalize, LinearSegmentedColormap, TwoSlopeNorm\nfrom ldtk import LDPSetCreator, BoxcarFilter\n</pre> import SOAP from SOAP import PHOENIX,Spec_mu from SOAP.fast_starspot import doppler_shift import numpy as np import matplotlib.pyplot as plt from matplotlib.cm import ScalarMappable, get_cmap from matplotlib.colors import Normalize, LinearSegmentedColormap, TwoSlopeNorm from ldtk import LDPSetCreator, BoxcarFilter In\u00a0[2]: Copied! <pre>transgrad = LinearSegmentedColormap.from_list('Random gradient 9491', (\n    # Edit this gradient at https://eltos.github.io/gradient/#Random%20gradient%209491=008080-FFF2F2-440154\n    (0.000, (1.000, 0.000, 0.000)),  # Bright red (#FF0000) at the low end\n    (0.500, (1.000, 1.000, 1.000)),  # Bright gray (white) at the middle\n    (1.000, (0.000, 0.000, 0.545))))\n</pre> transgrad = LinearSegmentedColormap.from_list('Random gradient 9491', (     # Edit this gradient at https://eltos.github.io/gradient/#Random%20gradient%209491=008080-FFF2F2-440154     (0.000, (1.000, 0.000, 0.000)),  # Bright red (#FF0000) at the low end     (0.500, (1.000, 1.000, 1.000)),  # Bright gray (white) at the middle     (1.000, (0.000, 0.000, 0.545)))) In\u00a0[3]: Copied! <pre>#Star\nradius=1    # Solar Radii\nmass=1      # Solar mass\nprot=24.47\nincl=90         # Inclination of the stellar rotation axis relative to the sky-plane\ndiffrotB=0      # Differential roation coeff\ndiffrotC=0      # Differential roation coeff\nlogg= 4.4\nlogg_sig=0.001\nfeh= 0.00\nfeh_sig= 0.01\nTeff=5777\nTeff_sig=10\n\n#Planet\nstart_psi=0.0\nPp=3.13   # Orbital period in days\ne=0.0           # Orbital eccentricity\nw=90.0          # Argument of periastron\nip=90        # Orbital inclination\nlbda=0       # Sky-projected spin-orbit misalignement\na=9          # Semi-major axis\nRp= 0.15      # Planetary radius in stellar radii\nMp= 317.8       # Planetary mass in Earth masses\n</pre> #Star radius=1    # Solar Radii mass=1      # Solar mass prot=24.47 incl=90         # Inclination of the stellar rotation axis relative to the sky-plane diffrotB=0      # Differential roation coeff diffrotC=0      # Differential roation coeff logg= 4.4 logg_sig=0.001 feh= 0.00 feh_sig= 0.01 Teff=5777 Teff_sig=10  #Planet start_psi=0.0 Pp=3.13   # Orbital period in days e=0.0           # Orbital eccentricity w=90.0          # Argument of periastron ip=90        # Orbital inclination lbda=0       # Sky-projected spin-orbit misalignement a=9          # Semi-major axis Rp= 0.15      # Planetary radius in stellar radii Mp= 317.8       # Planetary mass in Earth masses In\u00a0[4]: Copied! <pre>\u03bb = (5882, 5902)\n</pre> \u03bb = (5882, 5902) In\u00a0[5]: Copied! <pre>filters = [BoxcarFilter('filter',\u03bb[0]/10, \u03bb[1]/10)] #expresso spectograph bandpass 380, 788nm\nsc = LDPSetCreator(teff=(Teff, 43),    # parametros da estrela\nlogg=(logg,logg_sig),\n z=(feh, feh_sig),\nfilters=filters)\nps = sc.create_profiles()      \t         # Create the limb darkening profiles\nldcn, qe = ps.coeffs_qd(do_mc=True) #coeficientes e os seus erros de perfil quadr\u00e1tico\n</pre> filters = [BoxcarFilter('filter',\u03bb[0]/10, \u03bb[1]/10)] #expresso spectograph bandpass 380, 788nm sc = LDPSetCreator(teff=(Teff, 43),    # parametros da estrela logg=(logg,logg_sig),  z=(feh, feh_sig), filters=filters) ps = sc.create_profiles()      \t         # Create the limb darkening profiles ldcn, qe = ps.coeffs_qd(do_mc=True) #coeficientes e os seus erros de perfil quadr\u00e1tico <p>Where we use will import Phoenix spectra that match the stellar properties. These will be used to compute the RVs in the simulation</p> In\u00a0[6]: Copied! <pre>spQt = PHOENIX(wave_range=\u03bb, normalize=True, teff=Teff, logg=logg, Z=0)\ntplt={\"wave\":spQt.wave, \"flux\":spQt.flux}\n</pre> spQt = PHOENIX(wave_range=\u03bb, normalize=True, teff=Teff, logg=logg, Z=0) tplt={\"wave\":spQt.wave, \"flux\":spQt.flux} In\u00a0[7]: Copied! <pre>spQ=spQt\n</pre> spQ=spQt In\u00a0[8]: Copied! <pre>sim = SOAP.Simulation( pixel=spQ, pixel_spot=None, wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=140000, grid=600, active_regions=[], ring=None)\n</pre> sim = SOAP.Simulation( pixel=spQ, pixel_spot=None, wlll=(\u03bb[1]+\u03bb[0])/2, inst_reso=140000, grid=600, active_regions=[], ring=None) In\u00a0[9]: Copied! <pre># Set the properties of the star and planet\nsim.star.set(prot=prot,incl=incl,diffrotB=diffrotB,diffrotC=diffrotC,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff)\nsim.planet.set(P=Pp,t0=start_psi,e=e,w=w,ip=ip,lbda=lbda,a=a,Rp=Rp,Mp=Mp)\n</pre> # Set the properties of the star and planet sim.star.set(prot=prot,incl=incl,diffrotB=diffrotB,diffrotC=diffrotC,u1=ldcn[0][0],u2= ldcn[0][1], start_psi=start_psi,radius=radius,mass=mass,teff=Teff) sim.planet.set(P=Pp,t0=start_psi,e=e,w=w,ip=ip,lbda=lbda,a=a,Rp=Rp,Mp=Mp) In\u00a0[10]: Copied! <pre># Check the properties\nprint(sim.star)\nprint(sim.planet)\n</pre> # Check the properties print(sim.star) print(sim.planet)  <pre>SOAP.Star(prot=24.47 d; incl=90.0 deg; radius=1.0 solRad; teff=5777 K)\nSOAP.Planet(P=3.13 d; t0=0.0 d; e=0.0; w=90.0 deg; ip=90.0 deg; lbda=0.0 deg; a=9.0 solRad, Rp=0.15 solRad)\n</pre> In\u00a0[11]: Copied! <pre># Provide the phases normalized by the stellar rotation\npsi = np.linspace(-0.1,0.1,50) / sim.star.prot\n</pre> # Provide the phases normalized by the stellar rotation psi = np.linspace(-0.1,0.1,50) / sim.star.prot In\u00a0[12]: Copied! <pre>out=sim.calculate_signal(psi, renormalize_rv=True, template=tplt)\n</pre> out=sim.calculate_signal(psi, renormalize_rv=True, template=tplt)  In\u00a0[13]: Copied! <pre>absorption_spec=(1-sim.pixel_trans)*100\n</pre> absorption_spec=(1-sim.pixel_trans)*100 In\u00a0[14]: Copied! <pre>tr_dur=1./np.pi * np.arcsin(1./a *np.sqrt((1+Rp )**2.-a**2. *np.cos(np.radians(ip))**2.))\ntr_ingress_egress=1./np.pi * np.arcsin(1./a *np.sqrt((1.-Rp)**2.-a**2. *np.cos(np.radians(ip))**2.))\n</pre> tr_dur=1./np.pi * np.arcsin(1./a *np.sqrt((1+Rp )**2.-a**2. *np.cos(np.radians(ip))**2.)) tr_ingress_egress=1./np.pi * np.arcsin(1./a *np.sqrt((1.-Rp)**2.-a**2. *np.cos(np.radians(ip))**2.)) In\u00a0[15]: Copied! <pre>psi_planet=(psi*sim.star.prot/sim.planet.P).value\n</pre> psi_planet=(psi*sim.star.prot/sim.planet.P).value In\u00a0[16]: Copied! <pre>X,Y=np.meshgrid(sim.pixel.wave,psi_planet)\nfig, ax = plt.subplots(figsize=(13,7))\n\nnorm = TwoSlopeNorm(vmin=np.min(absorption_spec), vcenter=0, vmax=np.max(absorption_spec))  # Center at zero\nim=ax.pcolor(X,Y,absorption_spec, cmap=transgrad, norm=norm)\nax.set_xlabel(\"Wavelength \"+r\"$\\AA$\")\nax.set_ylabel(\"Orbital Phase\")\n\n\nplt.plot(\u03bb, [-tr_dur/2, -tr_dur/2], '-k')\nplt.plot(\u03bb, [tr_dur/2, tr_dur/2], '-k')\nplt.plot(\u03bb, [-tr_ingress_egress/2, -tr_ingress_egress/2], '--k')\nplt.plot(\u03bb, [tr_ingress_egress/2, tr_ingress_egress/2], '--k')\n\nsm = ScalarMappable(cmap=im.get_cmap())\nsm.set_clim(np.min(absorption_spec), np.max(absorption_spec))\n\nsm.set_array([])  # Set an empty array (required)\nfig = plt.gcf()\n\n# Get the position of the main image axes\nimage_position = im.axes.get_position()\n\n# Create the colorbar axes with a slightly smaller width for spacing\ncolorbard_width = image_position.width * 0.03  # Adjust width as needed\nax = fig.add_axes([image_position.x1+0.011, image_position.y0, colorbard_width, image_position.height])\nfig.colorbar(sm, cax=ax, label=\"Absorption (%)\")  # Add a label\n</pre> X,Y=np.meshgrid(sim.pixel.wave,psi_planet) fig, ax = plt.subplots(figsize=(13,7))  norm = TwoSlopeNorm(vmin=np.min(absorption_spec), vcenter=0, vmax=np.max(absorption_spec))  # Center at zero im=ax.pcolor(X,Y,absorption_spec, cmap=transgrad, norm=norm) ax.set_xlabel(\"Wavelength \"+r\"$\\AA$\") ax.set_ylabel(\"Orbital Phase\")   plt.plot(\u03bb, [-tr_dur/2, -tr_dur/2], '-k') plt.plot(\u03bb, [tr_dur/2, tr_dur/2], '-k') plt.plot(\u03bb, [-tr_ingress_egress/2, -tr_ingress_egress/2], '--k') plt.plot(\u03bb, [tr_ingress_egress/2, tr_ingress_egress/2], '--k')  sm = ScalarMappable(cmap=im.get_cmap()) sm.set_clim(np.min(absorption_spec), np.max(absorption_spec))  sm.set_array([])  # Set an empty array (required) fig = plt.gcf()  # Get the position of the main image axes image_position = im.axes.get_position()  # Create the colorbar axes with a slightly smaller width for spacing colorbard_width = image_position.width * 0.03  # Adjust width as needed ax = fig.add_axes([image_position.x1+0.011, image_position.y0, colorbard_width, image_position.height]) fig.colorbar(sm, cax=ax, label=\"Absorption (%)\")  # Add a label Out[16]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x7d8b803ee510&gt;</pre> In\u00a0[17]: Copied! <pre>from astropy.constants import M_earth, M_sun\n</pre> from astropy.constants import M_earth, M_sun In\u00a0[18]: Copied! <pre>Kp=(sim.planet.K)*(M_sun*sim.star.mass)/(sim.planet.Mp*(M_earth))\npshift=(Kp*np.sin(2*np.pi*psi_planet)).value\n</pre> Kp=(sim.planet.K)*(M_sun*sim.star.mass)/(sim.planet.Mp*(M_earth)) pshift=(Kp*np.sin(2*np.pi*psi_planet)).value  In\u00a0[19]: Copied! <pre>absorpt_prest=np.array([doppler_shift(sim.pixel.wave,absorption_spec[x],-1000*pshift[x]) for x in range(len(pshift))])\n</pre> absorpt_prest=np.array([doppler_shift(sim.pixel.wave,absorption_spec[x],-1000*pshift[x]) for x in range(len(pshift))]) In\u00a0[20]: Copied! <pre>X,Y=np.meshgrid(sim.pixel.wave,psi_planet)\nfig, ax = plt.subplots(figsize=(13,7))\n\nnorm = TwoSlopeNorm(vmin=np.min(absorpt_prest), vcenter=0, vmax=np.max(absorpt_prest))  # Center at zero\nim=ax.pcolor(X,Y,absorpt_prest, cmap=transgrad, norm=norm)\nax.set_xlabel(\"Wavelength \"+r\"$\\AA$\")\nax.set_ylabel(\"Orbital Phase\")\n\n\nplt.plot(\u03bb, [-tr_dur/2, -tr_dur/2], '-k')\nplt.plot(\u03bb, [tr_dur/2, tr_dur/2], '-k')\nplt.plot(\u03bb, [-tr_ingress_egress/2, -tr_ingress_egress/2], '--k')\nplt.plot(\u03bb, [tr_ingress_egress/2, tr_ingress_egress/2], '--k')\n\nsm = ScalarMappable(cmap=im.get_cmap())\nsm.set_clim(np.min(absorption_spec), np.max(absorption_spec))\n\nsm.set_array([])  # Set an empty array (required)\nfig = plt.gcf()\n\n# Get the position of the main image axes\nimage_position = im.axes.get_position()\n\n# Create the colorbar axes with a slightly smaller width for spacing\ncolorbard_width = image_position.width * 0.03  # Adjust width as needed\nax = fig.add_axes([image_position.x1+0.011, image_position.y0, colorbard_width, image_position.height])\nfig.colorbar(sm, cax=ax, label=\"Absorption (%)\")  # Add a label\n</pre> X,Y=np.meshgrid(sim.pixel.wave,psi_planet) fig, ax = plt.subplots(figsize=(13,7))  norm = TwoSlopeNorm(vmin=np.min(absorpt_prest), vcenter=0, vmax=np.max(absorpt_prest))  # Center at zero im=ax.pcolor(X,Y,absorpt_prest, cmap=transgrad, norm=norm) ax.set_xlabel(\"Wavelength \"+r\"$\\AA$\") ax.set_ylabel(\"Orbital Phase\")   plt.plot(\u03bb, [-tr_dur/2, -tr_dur/2], '-k') plt.plot(\u03bb, [tr_dur/2, tr_dur/2], '-k') plt.plot(\u03bb, [-tr_ingress_egress/2, -tr_ingress_egress/2], '--k') plt.plot(\u03bb, [tr_ingress_egress/2, tr_ingress_egress/2], '--k')  sm = ScalarMappable(cmap=im.get_cmap()) sm.set_clim(np.min(absorption_spec), np.max(absorption_spec))  sm.set_array([])  # Set an empty array (required) fig = plt.gcf()  # Get the position of the main image axes image_position = im.axes.get_position()  # Create the colorbar axes with a slightly smaller width for spacing colorbard_width = image_position.width * 0.03  # Adjust width as needed ax = fig.add_axes([image_position.x1+0.011, image_position.y0, colorbard_width, image_position.height]) fig.colorbar(sm, cax=ax, label=\"Absorption (%)\")  # Add a label Out[20]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x7d8b898765d0&gt;</pre> In\u00a0[21]: Copied! <pre>mask_T2_T3 = np.logical_and(psi_planet&gt; -tr_ingress_egress / 2, psi_planet&lt; tr_ingress_egress / 2)\nmask_T1_T4 = np.logical_and(psi_planet&gt; -tr_dur / 2, psi_planet&lt; tr_dur / 2)\n</pre> mask_T2_T3 = np.logical_and(psi_planet&gt; -tr_ingress_egress / 2, psi_planet&lt; tr_ingress_egress / 2) mask_T1_T4 = np.logical_and(psi_planet&gt; -tr_dur / 2, psi_planet&lt; tr_dur / 2) In\u00a0[22]: Copied! <pre>mean_T2_T3=np.mean(absorpt_prest[mask_T2_T3], axis=0)\nmean_T1_T4=np.mean(absorpt_prest[mask_T1_T4], axis=0)\n</pre> mean_T2_T3=np.mean(absorpt_prest[mask_T2_T3], axis=0) mean_T1_T4=np.mean(absorpt_prest[mask_T1_T4], axis=0) In\u00a0[23]: Copied! <pre>plt.plot(sim.pixel.wave,mean_T2_T3,\"k\", label=\"T2-T3\")\nplt.plot(sim.pixel.wave,mean_T1_T4,\"b\", label=\"T1-T4\")\nplt.legend()\nplt.xlim(5894,5898)\nplt.xlabel(\"Wavelength (\"+r\"$\\AA$)\")\nplt.ylabel(\"Absorption (%)\")\n</pre> plt.plot(sim.pixel.wave,mean_T2_T3,\"k\", label=\"T2-T3\") plt.plot(sim.pixel.wave,mean_T1_T4,\"b\", label=\"T1-T4\") plt.legend() plt.xlim(5894,5898) plt.xlabel(\"Wavelength (\"+r\"$\\AA$)\") plt.ylabel(\"Absorption (%)\") Out[23]: <pre>Text(0, 0.5, 'Absorption (%)')</pre> In\u00a0[24]: Copied! <pre>sim.visualize(output=out,plot_type=\"rv\")\n</pre> sim.visualize(output=out,plot_type=\"rv\")"},{"location":"notebooks/Sun_jupiter_phoenix/#transmission-spectrum-of-a-transit-event","title":"Transmission spectrum of a transit event\u00b6","text":""},{"location":"notebooks/Sun_jupiter_phoenix/#define-the-system-properties-hd209458","title":"Define the system properties (HD209458)\u00b6","text":""},{"location":"notebooks/Sun_jupiter_phoenix/#start-the-simulation","title":"Start the simulation\u00b6","text":""},{"location":"notebooks/compare_batman/","title":"Basic Example","text":"In\u00a0[1]: Copied! <pre>import batman\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> import batman import numpy as np import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>params = batman.TransitParams()\nparams.t0 = 0.                       #time of inferior conjunction\nparams.per = 1.                      #orbital period\nparams.rp = 0.15                      #planet radius (in units of stellar radii)\nparams.a = 15.                       #semi-major axis (in units of stellar radii)\nparams.inc = 90.                     #orbital inclination (in degrees)\nparams.ecc = 0.                      #eccentricity\nparams.w = 90.                       #longitude of periastron (in degrees)\nparams.u = [0.9, 0.1]                #limb darkening coefficients [u1, u2]\nparams.limb_dark = \"quadratic\"       #limb darkening model\n</pre> params = batman.TransitParams() params.t0 = 0.                       #time of inferior conjunction params.per = 1.                      #orbital period params.rp = 0.15                      #planet radius (in units of stellar radii) params.a = 15.                       #semi-major axis (in units of stellar radii) params.inc = 90.                     #orbital inclination (in degrees) params.ecc = 0.                      #eccentricity params.w = 90.                       #longitude of periastron (in degrees) params.u = [0.9, 0.1]                #limb darkening coefficients [u1, u2] params.limb_dark = \"quadratic\"       #limb darkening model In\u00a0[3]: Copied! <pre>t = np.linspace(-0.02, 0.02, 1000)\n</pre> t = np.linspace(-0.02, 0.02, 1000) In\u00a0[4]: Copied! <pre>m = batman.TransitModel(params, t)    #initializes model\nflux = m.light_curve(params)          #calculates light curve\n</pre> m = batman.TransitModel(params, t)    #initializes model flux = m.light_curve(params)          #calculates light curve In\u00a0[5]: Copied! <pre>plt.plot(t, flux)\nplt.xlabel(\"Time from central transit\")\nplt.ylabel(\"Relative flux\")\nplt.show()\n</pre> plt.plot(t, flux) plt.xlabel(\"Time from central transit\") plt.ylabel(\"Relative flux\") plt.show()   In\u00a0[6]: Copied! <pre>import SOAP\n</pre> import SOAP In\u00a0[7]: Copied! <pre>sim = SOAP.Simulation()\nsim.grid=801\n</pre> sim = SOAP.Simulation() sim.grid=801 In\u00a0[8]: Copied! <pre>print(sim.planet)\nsim.planet.Mp=300\n</pre> print(sim.planet) sim.planet.Mp=300 <pre>SOAP.Planet(P=4.0 d; t0=0.0 d; e=0.0; w=90.0 deg; ip=90.0 deg; lbda=0.0 deg; a=8.76 solRad, Rp=0.1 solRad)\n</pre> In\u00a0[9]: Copied! <pre>print(sim.star)\n</pre> print(sim.star) <pre>SOAP.Star(prot=25.05 d; incl=90.0 deg; radius=1.0 solRad; teff=5778 K)\n</pre> In\u00a0[10]: Copied! <pre>sim.planet.Rp=params.rp\nsim.planet.a=params.a\nsim.planet.P=params.per\nsim.star.u1=params.u[0]\nsim.star.u2=params.u[1]\nsim.active_regions=[]\n</pre> sim.planet.Rp=params.rp sim.planet.a=params.a sim.planet.P=params.per sim.star.u1=params.u[0] sim.star.u2=params.u[1] sim.active_regions=[] In\u00a0[11]: Copied! <pre>print(sim.planet)\n</pre> print(sim.planet) <pre>SOAP.Planet(P=1.0 d; t0=0.0 d; e=0.0; w=90.0 deg; ip=90.0 deg; lbda=0.0 deg; a=15.0 solRad, Rp=0.15 solRad)\n</pre> In\u00a0[12]: Copied! <pre>sim.star.prot=5\n</pre> sim.star.prot=5 In\u00a0[13]: Copied! <pre>out=sim.calculate_signal(psi=t*sim.planet.P/sim.star.prot)\n</pre> out=sim.calculate_signal(psi=t*sim.planet.P/sim.star.prot)  In\u00a0[14]: Copied! <pre>plt.plot(out.psi, out.flux)\nplt.plot(out.psi, flux)\n</pre> plt.plot(out.psi, out.flux) plt.plot(out.psi, flux) Out[14]: <pre>[&lt;matplotlib.lines.Line2D at 0x7e6a00df9810&gt;]</pre> In\u00a0[15]: Copied! <pre>plt.plot(out.psi,(out.flux-flux)*1e6)\n\nnp.mean((out.flux-flux)*1e6)\n</pre> plt.plot(out.psi,(out.flux-flux)*1e6)  np.mean((out.flux-flux)*1e6) Out[15]:  $-0.67780581 \\; \\mathrm{}$  In\u00a0[16]: Copied! <pre>plt.plot(out.psi, out.rv)\nprint(out.rv[0])\n</pre> plt.plot(out.psi, out.rv) print(out.rv[0]) <pre>0.024029537928860173 km / s\n</pre>"}]}